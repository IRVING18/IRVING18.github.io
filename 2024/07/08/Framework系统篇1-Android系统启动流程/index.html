<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Framework系统篇1-Android系统启动流程 | Android高级直通车</title><meta name="author" content="王征"><meta name="copyright" content="王征"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[toc]                                            一、系统启动入口 简图中我们关注的重点：  1、core、main、late-start三种类型任务 2、与AMS类似的系统进程是通过servicemanager来获取IBinder对象，从而得到BpBinder，进而通过binder来通信的 3、普通应用间，是通过Service组件，来获取IBind">
<meta property="og:type" content="article">
<meta property="og:title" content="Framework系统篇1-Android系统启动流程">
<meta property="og:url" content="https://irving18.github.io/2024/07/08/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Android高级直通车">
<meta property="og:description" content="[toc]                                            一、系统启动入口 简图中我们关注的重点：  1、core、main、late-start三种类型任务 2、与AMS类似的系统进程是通过servicemanager来获取IBinder对象，从而得到BpBinder，进而通过binder来通信的 3、普通应用间，是通过Service组件，来获取IBind">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://irving18.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-07-08T07:38:38.000Z">
<meta property="article:modified_time" content="2024-12-27T09:06:12.999Z">
<meta property="article:author" content="王征">
<meta property="article:tag" content="Android进阶">
<meta property="article:tag" content="Framework">
<meta property="article:tag" content="AMS">
<meta property="article:tag" content="系统服务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://irving18.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://irving18.github.io/2024/07/08/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Framework系统篇1-Android系统启动流程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Android高级直通车</span></a><a class="nav-page-title" href="/"><span class="site-name">Framework系统篇1-Android系统启动流程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Framework系统篇1-Android系统启动流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-08T07:38:38.000Z" title="发表于 2024-07-08 15:38:38">2024-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-27T09:06:12.999Z" title="更新于 2024-12-27 17:06:12">2024-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<!--# 目录-->
<!--- [一、系统启动入口](#jump1)-->
<!--    *   [（一）init.rc：标识core、main、late_start类型服务](#jump8_1_1)-->
<!--    *   [（二）系统主函数 init.cpp：执行顺序core > main > late_start](#jump8_1_2) -->
<!--        *   [1、core类型的服务进程是怎么执行的呢?](#jump8_1_2_1)-->
<!--        *   [2、那么main、late_start类型的服务进程在哪执行的呢？](#jump8_1_2_2)-->
<!--- [二、Servicemanager启动](#jump8)-->
<!--    *   [（一）ServiceManager主函数](#jump8_2)-->
<!--    *   [（二）svcinfo结构体，存储注册进来的Binder服务的实体](#jump8_3)-->
<!--    *   [（三）ServiceManager进程的特殊性：defaultServiceManager](#jump8_4)-->
<!--- [三、Zygoet启动](#jump3)-->
<!--    - [（一）Zygoet完整启动图：c->java](#jump3_0)-->
<!--    - [（二）c层](#jump3_1)-->
<!--        - [（1）c层主函数入口App_main.main](#jump3_1_1)-->
<!--        - [（2）AppRuntime::start()](#jump3_1_2)-->
<!--    - [（三）java层](#jump3_2)-->
<!--        - [（1）java层主函数入口ZygoteInit.main](#jump3_2_1)-->
<!--        - [（2）registerZygoteSocket：开启Socket通信](#jump3_2_2)-->
<!--        - [（3）preload（加载资源） & CopyOnWrite方式（fork进程）](#jump3_2_3)-->
<!--        - [（4）startSystemServer（fork system_server进程）](#jump3_2_4)-->
<!--        - [（5）runSelectLoop：无限循环等待创建进程命令调用](#jump3_2_5)-->
<!--        - [（6）runOnce fork进程，并调用新进程初始化](#jump3_2_6)-->
<!--    - [（四）Zygoet启动流程小结](#jump3_3)-->
<!--    - [（五）runOnce fork进程详情](#jump3_4)-->
<!--        -   [（1）java层：forkAndSpecialize](#jump3_4_1)-->
<!--        -   [（2）c层：nativeForkAndSpecialize](#jump3_4_2)-->
<!--        -   [（3）c层：fork()](#jump3_4_3)-->
<!--    - [（六）新进程运行](#jump3_5)-->
<!--        -   [（1）handleChildProc](#jump3_5_1)-->
<!--        -   [（2）zygoteInit 调度方法](#jump3_5_2)-->
<!--        -   [（3）applicationInit](#jump3_5_3)-->
<!--        -   [（4）invokeStaticMain](#jump3_5_4)-->
<!--        -   [（5）MethodAndArgsCaller](#jump3_5_5)-->
<!--        -   [（6）ActivityThread.main](#jump3_5_6)-->
<!--    - [（七）Zygoet fork进程总结](#jump3_6)-->
<!--- [四、system_server启动](#jump4)-->
<!--    - [（1）SystemServer由Zygoet fork启动](#jump4_1)-->
<!--    - [（2）调度AMS、PMS等其他系统服务，分类](#jump4_2)-->
<!--    - [（3）调度AMS、PMS服务的onStart()、onBootPhase()生命周期方法](#jump4_3)-->
<!--        - [3.1 AMS等.onStart()生命周期方法](#jump4_3_1)-->
<!--        - [3.2 AMS等.onBootPhase()生命周期方法](#jump4_3_2)-->


<h1 id="一、系统启动入口"><a href="#一、系统启动入口" class="headerlink" title="一、系统启动入口"></a><span id="jump1">一、系统启动入口</span></h1><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_1.jpg" alt="系统启动简图、AMS.png"></p>
<p>简图中我们关注的重点：</p>
<ul>
<li>1、core、main、late-start三种类型任务</li>
<li>2、与AMS类似的系统进程是通过servicemanager来获取IBinder对象，从而得到BpBinder，进而通过binder来通信的</li>
<li>3、普通应用间，是通过Service组件，来获取IBinder对象，从而得到BpBinder，进程通过binder来通信的；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_2.jpg" alt="Binder全流程图.png"></p>
<blockquote>
<p>&#x2F;system&#x2F;core&#x2F;init&#x2F;init.cpp<br>&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc</p>
</blockquote>
<h2 id="（一）init-rc：标识core、main、late-start类型服务"><a href="#（一）init-rc：标识core、main、late-start类型服务" class="headerlink" title="（一）init.rc：标识core、main、late_start类型服务 "></a><span id="jump8_1_1">（一）init.rc：标识core、main、late_start类型服务 </span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">6.0</span>以前的源码</span><br><span class="line"><span class="comment">//1、Linux以服务形式启动ServiceManager</span></span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="comment">//2、servicemanager被注册成core类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    //3、<span class="title">system</span>系统身份启动</span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span> </span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    //4、标识为关键服务：挂掉后会被系统重启、挂掉4次以上会直接重启设备；</span></span><br><span class="line"><span class="class">    <span class="title">critical</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">healthd</span></span></span><br><span class="line"><span class="class">    //5、当服务重启时，会连带重启<span class="title">zygote</span>、<span class="title">media</span>、<span class="title">surfaceflinger</span>进程</span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span> </span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">surfaceflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">drm</span></span></span><br></pre></td></tr></table></figure>

<p>什么是core类型的服务？<br>在init.rc、init.zygote32.rc	等rc中配置的服务进程中，会用class 标识所属</p>
<ul>
<li>1、服务分类为core &gt; main &gt; late_start<ul>
<li>core：ServiceManager、surfaceflinger、debuggerd。。</li>
<li>main：zygoet、media。。</li>
<li>late_start：cmd_services、一般系统定制的服务会放在这</li>
</ul>
</li>
<li>2、在init.cpp <ul>
<li>main方法中，处理各个类型的任务执行</li>
<li>指向init.rc中on 注册的任务</li>
</ul>
</li>
</ul>
<p>重点：</p>
<ul>
<li>1、Linux以service服务命形式启动ServiceManager进程</li>
<li>2、ServiceManager被标识为core类型，最先启动的进程；<ul>
<li>core &gt; main（zygoet） &gt; late_int（一般系统定制服务放在这）</li>
<li>zygoet属于main类型，会晚于ServiceManager启动</li>
</ul>
</li>
<li>3、ServiceManager是以system系统身份启动</li>
<li>4、ServiceManager会被标识为关键服务：<ul>
<li>挂掉后会被系统重启</li>
<li>挂掉4次以上会直接重启设备；</li>
</ul>
</li>
<li>5、当ServiceManager进程重启时，会连带重启<ul>
<li>zygote进程</li>
<li>media进程</li>
<li>surfaceflinger进程</li>
</ul>
</li>
</ul>
<h2 id="（二）系统主函数-init-cpp：执行顺序core-main-late-start"><a href="#（二）系统主函数-init-cpp：执行顺序core-main-late-start" class="headerlink" title="（二）系统主函数 init.cpp：执行顺序core &gt; main &gt; late_start"></a><span id="jump8_1_2">（二）系统主函数 init.cpp：执行顺序core &gt; main &gt; late_start</span></h2><blockquote>
<p>在系统启动时在系统启动时，Linux会去寻找&#x2F;init 的可执行文件，即init.cpp</p>
</blockquote>
<h3 id="1、core类型的服务进程是怎么执行的呢？"><a href="#1、core类型的服务进程是怎么执行的呢？" class="headerlink" title="1、core类型的服务进程是怎么执行的呢？ "></a><span id="jump8_1_2_1">1、core类型的服务进程是怎么执行的呢？ </span></h3><p>注意区分late-init 和 rc中late_start不是一个东西；</p>
<ul>
<li><p>late-init 是cpp main函数的中控制init.rc 中on late-init执行的</p>
</li>
<li><p>late_start 是服务进程的分类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#/system/core/init/init.cpp</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="comment">//1、加载init.rc</span></span><br><span class="line">    init_parse_config_file(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line">    <span class="comment">//2、对应会执行init.rc中on early-init中的命令</span></span><br><span class="line">    action_for_each_trigger(<span class="string">&quot;early-init&quot;</span>, action_add_queue_tail);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、对应会执行init.rc中on init中的命令，这两个init基本都是mkdir、chomd操作文件；</span></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    action_for_each_trigger(<span class="string">&quot;init&quot;</span>, action_add_queue_tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、这里的对应的init.rc中on late-init的命令才是重点</span></span><br><span class="line">    <span class="comment">// - 其实会执行boot，也就是init.rc中on boot下的命令；</span></span><br><span class="line">    <span class="comment">// - 在on boot中会去执行class_start core，即启动注册成core类型的服务进程</span></span><br><span class="line">    action_for_each_trigger(<span class="string">&quot;late-init&quot;</span>, action_add_queue_tail);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//这里就是顺序执行上边的任务</span></span><br><span class="line">        execute_one_command();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1、在系统启动时在系统启动时，Linux会去寻找&#x2F;init 的可执行文件，即init.cpp</p>
</li>
<li><p>2、会执行init.cpp的main()主函数</p>
</li>
<li><p>3、在main()主函数中会去加载init.rc文件</p>
<ul>
<li>依次执行init.rc中的：</li>
<li>on early-init</li>
<li>on init</li>
<li>on late-init：回去执行on boot -&gt; class_start core 启动core类型的服务进程</li>
</ul>
</li>
</ul>
<p>init.rc 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    ...</span><br><span class="line">    mkdir /mnt <span class="number">0775</span> root system</span><br><span class="line">    </span><br><span class="line">on init</span><br><span class="line">    ...</span><br><span class="line">    mkdir /sys/fs/cgroup/memory <span class="number">0750</span> root system</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on late-init</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">//涉及main、late_start任务注册，但是不会先于onboot执行，</span></span><br><span class="line">    <span class="comment">//因为他里边只是注册，执行顺序还是在execute_one_command控制死的，同步执行</span></span><br><span class="line">    trigger fs </span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">//执行on boot</span></span><br><span class="line">    trigger boot </span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    ..</span><br><span class="line">    class_start core <span class="comment">//启动core类型的所有服务进程</span></span><br></pre></td></tr></table></figure>

<p>上边我们看到了如何执行到core类型服务的了</p>
<ul>
<li>init.cpp <ul>
<li>-&gt; main() <ul>
<li>-&gt; action_for_each_trigger(“late-init”)<ul>
<li>-&gt; 执行init.rc文件<ul>
<li>on late-init <ul>
<li>-&gt; on boot<ul>
<li>-&gt; class_start core</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、那么main、late-start类型的服务进程在哪执行的呢？"><a href="#2、那么main、late-start类型的服务进程在哪执行的呢？" class="headerlink" title="2、那么main、late_start类型的服务进程在哪执行的呢？ "></a><span id="jump8_1_2_2">2、那么main、late_start类型的服务进程在哪执行的呢？ </span></h3><p>上边init.rc源码里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">on late-init</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">//涉及main、late_start任务注册，但是不会先于onboot执行，</span></span><br><span class="line">    <span class="comment">//因为他里边只是注册，执行顺序还是在execute_one_command控制死的，同步执行</span></span><br><span class="line">    trigger fs </span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">//执行on boot</span></span><br><span class="line">    trigger boot </span><br></pre></td></tr></table></figure>
<p>trigger fs就是解开的题解：</p>
<blockquote>
<p>这个section一般在init.${ro.hardware}.rc中定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># init.$&#123;ro.hardware&#125;.rc</span></span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    ...    mount_all fstab</span><br></pre></td></tr></table></figure>
<p>在“fs”section中会执行mount_all fstab命令。fstab是Android下比较重要的配置文件，它包含了系统在启动时挂载文件系统和存储设备的详细信息。对应的处理函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_mount_all</span><span class="params">(<span class="type">int</span> nargs, <span class="type">char</span> **args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret == FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 这里就将&quot;nonencrypted&quot;中的操作加入到操作队列中，</span></span><br><span class="line">        <span class="comment">// 因为他里边只是注册，执行顺序还是在execute_one_command控制死的同步执行，所以还是会等on boot先执行完，再执行；</span></span><br><span class="line">        <span class="comment">//也就是执行顺序：core &gt; main &gt; late_start</span></span><br><span class="line">        action_for_each_trigger(<span class="string">&quot;nonencrypted&quot;</span>, action_add_queue_tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此就会执行到init.rc的on nonencrypted</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br></pre></td></tr></table></figure>
<p>也就是启动main、late_start两个类型的服务进程</p>
<p>完整链路：</p>
<ul>
<li>init.cpp <ul>
<li>-&gt; main() <ul>
<li>-&gt; action_for_each_trigger(“late-init”)注册<ul>
<li>-&gt; 执行init.rc文件<ul>
<li>on late-init （init.rc文件）<ul>
<li>-&gt; on fs （init.rc文件）<ul>
<li>mount_all fstab —&gt; do_mount_all()方法执行<ul>
<li>action_for_each_trigger(“nonencrypted”)注册<ul>
<li>on nonencrypted （init.rc文件）<ul>
<li>顺序②class_start main</li>
<li>顺序③class_start late_start</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>-&gt; on boot （init.rc文件）<ul>
<li>-&gt; 顺序①class_start core</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二、Servicemanager启动"><a href="#二、Servicemanager启动" class="headerlink" title="二、Servicemanager启动"></a><span id="jump8">二、Servicemanager启动</h1><blockquote>
<p>上文中core任务启动时，就会走Servicemanager的主函数调用</p>
</blockquote>
<h2 id="（一）ServiceManager主函数"><a href="#（一）ServiceManager主函数" class="headerlink" title="（一）ServiceManager主函数"></a><span id="jump8_2">（一）ServiceManager主函数</span></h2><p>ServiceManager是一个独立的可执行文件，在设备中的进程名称是<span style="color:red;">&#x2F;system&#x2F;bin&#x2F;servicemanager</span>，这个也是其可执行文件的路径。</p>
<p>ServiceManager实现源码的位于这个路径：</p>
<blockquote>
<p>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_3.jpg" alt="img"></p>
<p>其main函数的主要内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="comment">//1、是打开Binder，并指定缓存大小为128k，比正常的binder 1016kb小一些</span></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;failed to open binder driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、把自己注册给binder驱动</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//3、开始轮询处理请求</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，主要做了三件事情：</p>
<ul>
<li>1、binder_open(128*1024); <ul>
<li>是打开Binder，并指定缓存大小为128k，由于ServiceManager提供的接口很简单（下文会讲到），因此并不需要普通进程那么多（1M - 8K）的缓存</li>
</ul>
</li>
<li>2、binder_become_context_manager(bs) <ul>
<li>使自己成为Context Manager（上下文管理者）。这里的Context Manager是Binder驱动里面的名称，等同于ServiceManager。</li>
<li>binder_become_context_manager的方法实现只有一行代码：ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0); 看过Binder驱动部分解析的内容，这行代码应该很容易理解了；就是把自己注册给binder驱动的一个特殊位置，即handle&#x3D;0的位置</li>
</ul>
</li>
<li>3、binder_loop(bs, svcmgr_handler); <ul>
<li>是在循环执行，等待其他模块请求服务，addService、getService</li>
</ul>
</li>
</ul>
<p>service_manager.c中的实现与普通Binder服务的实现有些不一样：并没有通过继承接口类来实现，而是通过几个c语言的函数来完成了实现。这个文件中的主要方法如下：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>main</td>
<td>可执行文件入口函数，刚刚已经做过说明</td>
</tr>
<tr>
<td>svcmgr_handler</td>
<td>请求的入口函数，类似于普通Binder服务的onTransact</td>
</tr>
<tr>
<td>do_add_service</td>
<td>注册一个Binder服务</td>
</tr>
<tr>
<td>do_find_service</td>
<td>通过名称查找一个已经注册的Binder服务</td>
</tr>
</tbody></table>
<h2 id="（二）svcinfo结构体，存储注册进来的Binder服务的实体"><a href="#（二）svcinfo结构体，存储注册进来的Binder服务的实体" class="headerlink" title="（二）svcinfo结构体，存储注册进来的Binder服务的实体"></a><span id="jump8_3">（二）svcinfo结构体，存储注册进来的Binder服务的实体</span></h2><p>ServiceManager中，通过svcinfo结构体来描述已经注册的Binder服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个服务，说明这玩意是个链表保存的</span></span><br><span class="line">    <span class="type">uint32_t</span> handle; <span class="comment">//句柄，对应可获取BBinder服务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> <span class="title">death</span>;</span></span><br><span class="line">    <span class="type">int</span> allow_isolated;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> name[<span class="number">0</span>]; <span class="comment">//addService()时注册的Binder服务名称，如power</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>next是一个指针，指向下一个服务，通过这个指针将所有服务串成了链表。</li>
<li>handle是指向Binder服务的句柄，这个句柄是由Binder驱动翻译，指向了Binder服务的实体（参见驱动中：Binder中的“面向对象”）</li>
<li>name是服务的名称。</li>
</ul>
<p>其实ServiceManager就像是个Map一样，用name-&gt;handle，来通过名字来找Binder服务</p>
<h2 id="（三）ServiceManager进程的特殊性：defaultServiceManager"><a href="#（三）ServiceManager进程的特殊性：defaultServiceManager" class="headerlink" title="（三）ServiceManager进程的特殊性：defaultServiceManager"></a><span id="jump8_4">（三）ServiceManager进程的特殊性：defaultServiceManager</span></h2><p>普通的Binder服务我们需要通过ServiceManager来获取接口才能调用，那么ServiceManager的接口有如何获得呢？</p>
<p>在libbinder中，提供了一个<strong>defaultServiceManager</strong> 方法来获取ServiceManager的Proxy，并且这个方法不需要传入参数。</p>
<p>原因：Binder的实现中，为ServiceManager留了一个特殊的位置，不需要像普通服务那样通过标识去查找。<strong>defaultServiceManager</strong> 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; <span class="title function_">defaultServiceManager</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="三、Zygoet启动"><a href="#三、Zygoet启动" class="headerlink" title="三、Zygoet启动"></a><span id="jump3"/>三、Zygoet启动</h1><h2 id="（一）Zygoet完整启动图：c-java"><a href="#（一）Zygoet完整启动图：c-java" class="headerlink" title="（一）Zygoet完整启动图：c-&gt;java"></a><span id="jump3_0"/>（一）Zygoet完整启动图：c-&gt;java</h2><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_4.jpg" alt="image.png"></p>
<blockquote>
<p>&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp<br>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</p>
<p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;</p>
<ul>
<li>ZygoteInit.java</li>
<li>Zygote.java</li>
<li>ZygoteConnection.java</li>
</ul>
<p>&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;net&#x2F;LocalServerSocket.java<br>&#x2F;system&#x2F;core&#x2F;libutils&#x2F;Threads.cpp</p>
</blockquote>
<h2 id="（二）c层"><a href="#（二）c层" class="headerlink" title="（二）c层"></a><span id="jump3_1"/>（二）c层</h2><p>和Servicemanager类似，Zygoet在main任务中被执行；<br>它的启动代码在：<br>&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp 中</p>
<h3 id="（1）c层主函数入口app-main-main"><a href="#（1）c层主函数入口app-main-main" class="headerlink" title="（1）c层主函数入口app_main.main"></a><span id="jump3_1_1"/>（1）c层主函数入口app_main.main</h3><p>只留下核心：</p>
<ul>
<li>1、加载AppRuntime类</li>
<li>2、设置Zygoet进程名</li>
<li>3、启动AppRuntime start</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#/frameworks/base/cmds/app_process/app_main.<span class="function">cpp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、加载AppRuntime类</span></span><br><span class="line">    <span class="comment">// 传到的参数argv为“-Xzygote /system/bin --zygote --start-system-server”</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、设置进程名</span></span><br><span class="line">    <span class="built_in">set_process_name</span>(niceName.<span class="built_in">string</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、启动AppRuntime 【见小节（2）AppRuntime::start()】</span></span><br><span class="line">    runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）AppRuntime-start"><a href="#（2）AppRuntime-start" class="headerlink" title="（2）AppRuntime::start()"></a><span id="jump3_1_2"/>（2）AppRuntime::start()</h3><p>核心方法：</p>
<ul>
<li>1、虚拟机vm创建，并设置调优参数</li>
<li>2、JNI方法注册</li>
<li>3、通过JNI调用java层：ZygoteInit.main()方法【见（三）java层】</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#/frameworks/base/core/jni/AndroidRuntime.<span class="function">cpp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> Vector&lt;String8&gt;&amp; options, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、虚拟机vm创建，并设置调优参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2、JNI方法注册</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、通过JNI调用java层：ZygoteInit.main()方法【见（三）java层】</span></span><br><span class="line">        env-&gt;<span class="built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（三）java层"><a href="#（三）java层" class="headerlink" title="（三）java层"></a><span id="jump3_2"/>（三）java层</h2><p>c层通过JNI会调用到此：</p>
<h3 id="（1）java层主函数入口ZygoteInit-main"><a href="#（1）java层主函数入口ZygoteInit-main" class="headerlink" title="（1）java层主函数入口ZygoteInit.main"></a><span id="jump3_2_1"/>（1）java层主函数入口ZygoteInit.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">    <span class="comment">//1、为Zygote注册socket【见小节（2）registerZygoteSocket】</span></span><br><span class="line">    registerZygoteSocket(socketName); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、预加载类和资源【见小节（3）preload】</span></span><br><span class="line">    preload(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、启动system_server【见小节3.4】</span></span><br><span class="line">    startSystemServer(abiList, socketName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4、进入循环模式【见小节3.5】</span></span><br><span class="line">    runSelectLoop(abiList); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）registerZygoteSocket：开启Socket通信"><a href="#（2）registerZygoteSocket：开启Socket通信" class="headerlink" title="（2）registerZygoteSocket：开启Socket通信"></a><span id="jump3_2_2"/>（2）registerZygoteSocket：开启Socket通信</h3><p>核心目的：开启Socket本地服务端，用于监听AMS发送的创建进程请求；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerZygoteSocket</span><span class="params">(String socketName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sServerSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> fileDesc;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fullSocketName</span> <span class="operator">=</span> ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> System.getenv(fullSocketName);</span><br><span class="line">            fileDesc = Integer.parseInt(env);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>();</span><br><span class="line">            fd.setInt$(fileDesc); <span class="comment">//设置文件描述符</span></span><br><span class="line">            sServerSocket = <span class="keyword">new</span> <span class="title class_">LocalServerSocket</span>(fd); <span class="comment">//创建Socket的本地服务端</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）preload-CopyOnWrite方式（fork进程）"><a href="#（3）preload-CopyOnWrite方式（fork进程）" class="headerlink" title="（3）preload &amp; CopyOnWrite方式（fork进程）"></a><span id="jump3_2_3"/>（3）preload &amp; CopyOnWrite方式（fork进程）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preload</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//预加载位于/system/etc/preloaded-classes文件中的类</span></span><br><span class="line">    preloadClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载资源，包含drawable和color资源</span></span><br><span class="line">    preloadResources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载OpenGL</span></span><br><span class="line">    preloadOpenGL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过System.loadLibrary()方法，</span></span><br><span class="line">    <span class="comment">//预加载&quot;android&quot;,&quot;compiler_rt&quot;,&quot;jnigraphics&quot;这3个共享库</span></span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载 文本连接符资源</span></span><br><span class="line">    preloadTextResources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅用于zygote进程，用于内存共享的进程</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心目的：执行Zygote进程的初始化</p>
<ul>
<li>类加载，采用反射机制Class.forName()方法来加载。</li>
<li>资源加载，主要是 com.android.internal.R.array.preloaded_drawables和com.android.internal.R.array.preloaded_color_state_lists，</li>
<li>在应用程序中以com.android.internal.R.xxx开头的资源，便是此时由Zygote加载到内存的。</li>
</ul>
<p>zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下：</p>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_5.jpg" alt="image.png"></p>
<h3 id="（4）startSystemServer-（fork-system-server进程）"><a href="#（4）startSystemServer-（fork-system-server进程）" class="headerlink" title="（4）startSystemServer （fork system_server进程）"></a><span id="jump3_2_4"/>（4）startSystemServer （fork system_server进程）</h3><p>核心目的：</p>
<ul>
<li>1、fork system_server 进程，</li>
<li>2、调用system_server进程初始化方法；</li>
</ul>
<p>更详细：<br><a target="_blank" rel="noopener" href="https://gityuan.com/2016/02/14/android-system-server/">https://gityuan.com/2016/02/14/android-system-server/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">startSystemServer</span><span class="params">(String abiList, String socketName)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、fork system_server 进程</span></span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">            parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">            parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            parsedArgs.permittedCapabilities,</span><br><span class="line">            parsedArgs.effectiveCapabilities);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、进入子进程system_server</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成system_server进程剩余的工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（5）runSelectLoop：无限循环等待创建进程命令调用"><a href="#（5）runSelectLoop：无限循环等待创建进程命令调用" class="headerlink" title="（5）runSelectLoop：无限循环等待创建进程命令调用"></a><span id="jump3_2_5"/>（5）runSelectLoop：无限循环等待创建进程命令调用</h3><p>核心：</p>
<ul>
<li>1、开启死循环，轮询获取socket创建进程任务</li>
<li>2、无任务时poll()阻塞</li>
<li>3、调用runOnce() fork进程；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    <span class="comment">//2、开启循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//3、获取socket发送的数据 pollFds</span></span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> <span class="title class_">StructPollfd</span>[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> <span class="title class_">StructPollfd</span>();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="type">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、阻塞：处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class="line">        Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、根据参数runOnce() fork进程</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> peers.get(i).runOnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）runOnce-fork进程，并调用新进程初始化"><a href="#（6）runOnce-fork进程，并调用新进程初始化" class="headerlink" title="（6）runOnce fork进程，并调用新进程初始化"></a><span id="jump3_2_6"/>（6）runOnce fork进程，并调用新进程初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    <span class="comment">//1、读取socket客户端发送过来的参数列表</span></span><br><span class="line">    args = readArgumentList();</span><br><span class="line">    <span class="comment">//2、fork 进程</span></span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">            parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">            parsedArgs.appDataDir);</span><br><span class="line">    <span class="comment">//3、调用新进程方法初始化</span></span><br><span class="line">    handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（四）Zygoet启动流程小结"><a href="#（四）Zygoet启动流程小结" class="headerlink" title="（四）Zygoet启动流程小结"></a><span id="jump3_3"/>（四）Zygoet启动流程小结</h2><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_6.jpg" alt="image.png"></p>
<ol>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；</li>
<li>zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li>
</ol>
<h2 id="（五）runOnce-fork进程详情"><a href="#（五）runOnce-fork进程详情" class="headerlink" title="（五）runOnce fork进程详情"></a><span id="jump3_4"/>（五）runOnce fork进程详情</h2><h3 id="（1）java层：forkAndSpecialize"><a href="#（1）java层：forkAndSpecialize" class="headerlink" title="（1）java层：forkAndSpecialize"></a><span id="jump3_4_1"/>（1）java层：forkAndSpecialize</h3><p>上边我们看到runOnce中调用了此方法，继续追</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">forkAndSpecialize</span><span class="params">(<span class="type">int</span> uid, <span class="type">int</span> gid, <span class="type">int</span>[] gids, <span class="type">int</span> debugFlags, <span class="type">int</span>[][] rlimits, <span class="type">int</span> mountExternal, String seInfo, String niceName, <span class="type">int</span>[] fdsToClose, String instructionSet, String appDataDir)</span> &#123;</span><br><span class="line">    <span class="comment">//1、前置fork方法，核心是申请堆内存等</span></span><br><span class="line">    VM_HOOKS.preFork(); </span><br><span class="line">    <span class="comment">//2、调用c层方法，继续fork流程</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir); <span class="comment">//【见小节9】</span></span><br><span class="line">    ...</span><br><span class="line">    VM_HOOKS.postForkCommon(); <span class="comment">//【见小节11】</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）c层：nativeForkAndSpecialize"><a href="#（2）c层：nativeForkAndSpecialize" class="headerlink" title="（2）c层：nativeForkAndSpecialize"></a><span id="jump3_4_2"/>（2）c层：nativeForkAndSpecialize</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(..)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ForkAndSpecializeCommon</span>(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, <span class="literal">false</span>, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">pid_t</span> <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="type">uid_t</span> uid, <span class="type">gid_t</span> gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, <span class="type">bool</span> is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//fork子进程 【见流程10.1】</span></span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//进入子进程</span></span><br><span class="line">    <span class="built_in">DetachDescriptors</span>(env, fdsToClose); <span class="comment">//关闭并清除文件描述符</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入父进程，即Zygote进程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）c层：fork"><a href="#（3）c层：fork" class="headerlink" title="（3）c层：fork()"></a><span id="jump3_4_3"/>（3）c层：fork()</h3><p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。</p>
<blockquote>
<p>父进程中，fork返回新创建的子进程的pid;<br>子进程中，fork返回0；<br>当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</p>
</blockquote>
<p>copy-on-write过程：当父子进程任一方修改内存数据时（这是on-write时机），才发生缺页中断，从而分配新的物理内存（这是copy操作）。</p>
<p>copy-on-write原理：写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork过程只拷贝父进程的页表，并标记这些页表是只读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常(page fault)，Linux收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。</p>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_5.jpg" alt="image.png"></p>
<h2 id="（六）新进程运行"><a href="#（六）新进程运行" class="headerlink" title="（六）新进程运行"></a><span id="jump3_5"/>（六）新进程运行</h2><p>在前面runOnce()过程中调用forkAndSpecialize()创建完新进程后，返回值pid&#x3D;0(即运行在子进程)继续开始执行handleChildProc()方法。</p>
<h3 id="（1）handleChildProc"><a href="#（1）handleChildProc" class="headerlink" title="（1）handleChildProc"></a><span id="jump3_5_1"/>（1）handleChildProc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    <span class="comment">//执行目标类的main()方法 </span></span><br><span class="line">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）zygoteInit-调度方法"><a href="#（2）zygoteInit-调度方法" class="headerlink" title="（2）zygoteInit 调度方法"></a><span id="jump3_5_2"/>（2）zygoteInit 调度方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">zygoteInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    <span class="comment">// 1、通用的一些初始化【见流程14.1】</span></span><br><span class="line">    commonInit(); </span><br><span class="line">    <span class="comment">// 2、zygote初始化 【见流程14.2】</span></span><br><span class="line">    nativeZygoteInit(); </span><br><span class="line">    <span class="comment">// 3、应用初始化【见流程14.3】</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）applicationInit"><a href="#（3）applicationInit" class="headerlink" title="（3）applicationInit"></a><span id="jump3_5_3"/>（3）applicationInit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">applicationInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    <span class="comment">//true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置虚拟机的内存利用率参数值为0.75</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = <span class="keyword">new</span> <span class="title class_">Arguments</span>(argv); <span class="comment">//解析参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用startClass的static方法 main() 【见流程15】</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（4）invokeStaticMain"><a href="#（4）invokeStaticMain" class="headerlink" title="（4）invokeStaticMain"></a><span id="jump3_5_4"/>（4）invokeStaticMain</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="literal">true</span>, classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> m.getModifiers();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。【见流程16】</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteInit</span>.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）MethodAndArgsCaller"><a href="#（5）MethodAndArgsCaller" class="headerlink" title="（5）MethodAndArgsCaller"></a><span id="jump3_5_5"/>（5）MethodAndArgsCaller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据传递过来的参数，此处反射调用ActivityThread.main()方法【见流程17】</span></span><br><span class="line">            mMethod.invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，总算是进入到了ActivityThread类的main()方法。</p>
<h3 id="（6）ActivityThread-main"><a href="#（6）ActivityThread-main" class="headerlink" title="（6）ActivityThread.main"></a><span id="jump3_5_6"/>（6）ActivityThread.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//创建主线程looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    <span class="comment">//attach到系统进程</span></span><br><span class="line">    thread.attach(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程进入循环状态</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（七）Zygoet-fork进程总结"><a href="#（七）Zygoet-fork进程总结" class="headerlink" title="（七）Zygoet fork进程总结"></a><span id="jump3_6"/>（七）Zygoet fork进程总结</h2><p>Process.start()方法是阻塞操作，等待直到进程创建完成并返回相应的新进程pid，才完成该方法。</p>
<p>当App第一次启动时或者启动远程Service，即AndroidManifest.xml文件中定义了process:remote属性时，都需要创建进程。比如当用户点击桌面的某个App图标，桌面本身是一个app（即Launcher App），那么Launcher所在进程便是这次创建新进程的发起进程，该通过binder发送消息给system_server进程，该进程承载着整个java framework的核心服务。system_server进程从Process.start开始，执行创建进程，流程图（以进程的视角）如下：</p>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_8.jpg" alt="image.png"></p>
<ul>
<li>（1）system_server进程（即流程1~3）：通过Process.start()方法发起创建新进程请求，会先收集各种新进程uid、gid、nice-name等相关的参数，然后通过socket通道发送给zygote进程；</li>
<li>（2）zygote进程（即流程4~12）：接收到system_server进程发送过来的参数后封装成Arguments对象，图中绿色框forkAndSpecialize()方法是进程创建过程中最为核心的一个环节（详见流程6），其具体工作是依次执行下面的3个方法：<ul>
<li>preFork()：先停止Zygote的4个Daemon子线程（java堆内存整理线程、对线下引用队列线程、析构线程以及监控线程）的运行以及初始化gc堆；</li>
<li>nativeForkAndSpecialize()：调用linux的fork()出新进程，创建Java堆处理的线程池，重置gc性能数据，设置进程的信号处理函数，启动JDWP线程；</li>
<li>postForkCommon()：在启动之前被暂停的4个Daemon子线程。</li>
</ul>
</li>
<li>（3）新进程（即流程13~15）：进入handleChildProc()方法，设置进程名，打开binder驱动，启动新的binder线程；然后设置art虚拟机参数，再反射调用目标类的main()方法，即Activity.main()方法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gityuan.com/2016/03/26/app-process-create/">https://gityuan.com/2016/03/26/app-process-create/</a></p>
<h1 id="四、system-server启动"><a href="#四、system-server启动" class="headerlink" title="四、system_server启动"></a><span id="jump4"/>四、system_server启动</h1><h2 id="（一）SystemServer启动"><a href="#（一）SystemServer启动" class="headerlink" title="（一）SystemServer启动"></a>（一）SystemServer启动</h2><h3 id="（1）SystemServer由Zygoet-fork启动"><a href="#（1）SystemServer由Zygoet-fork启动" class="headerlink" title="（1）SystemServer由Zygoet fork启动"></a><span id="jump4_1"/>（1）SystemServer由Zygoet fork启动</h3><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_9.jpg" alt="image.png"><br>关键点：</p>
<ul>
<li>（1）Zygoet进程属于main类型启动任务</li>
<li>（2）Zygoet启动之后会先fork system_server进程出来；</li>
<li>（3）system_server进程中会启动AMS&#x2F;WMS等这些系统服务<ul>
<li>AMS、WMS都运行在system_server进程中</li>
<li>system_server进程是在framework-res.apk中的，里边还包含关机弹框等UI</li>
</ul>
</li>
</ul>
<h3 id="（2）SystemServer-main"><a href="#（2）SystemServer-main" class="headerlink" title="（2）SystemServer.main()"></a>（2）SystemServer.main()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SystemServer</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先初始化SystemServer对象，再调用对象的run()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）SystemServer-run-，调度AMS、PMS等其他系统服务，分类"><a href="#（3）SystemServer-run-，调度AMS、PMS等其他系统服务，分类" class="headerlink" title="（3）SystemServer.run()，调度AMS、PMS等其他系统服务，分类"></a>（3）SystemServer.run()，调度AMS、PMS等其他系统服务，分类</h3><p>由system_server调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#http:<span class="comment">//aospxref.com/android-6.0.1_r9/xref/frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这个是管理各个服务的，如pms、wms的启动、停止等</span></span><br><span class="line">    <span class="comment">//注意：和Service Manager 不是一个东西</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、启动引导服务：AMS、PMS、PowerManagerServic</span></span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        <span class="comment">//2、启动核心服务：BatteryService、UsageStatsService和WebViewUpdateService</span></span><br><span class="line">        startCoreServices();</span><br><span class="line">        <span class="comment">//3、启动其他服务：如WMS、CameraService、AlarmManagerService、VrManagerService</span></span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别三类服务：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>服务</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap引导服务</td>
<td>AMS、PMS、PowerManagerService</td>
</tr>
<tr>
<td>Core核心服务</td>
<td>BatteryService等</td>
</tr>
<tr>
<td>Other其他服务</td>
<td>WMS、CameraService、AlarmManagerService、JobSchedulerService</td>
</tr>
</tbody></table>
<p>都在这里调度，且运行在system_server进程中</p>
<h2 id="（二）先来认识SystemServiceManager-管理者"><a href="#（二）先来认识SystemServiceManager-管理者" class="headerlink" title="（二）先来认识SystemServiceManager 管理者"></a>（二）先来认识SystemServiceManager 管理者</h2><p>mSystemServiceManager是管理服务的工具，在startCoreService()等方法中会调用到</p>
<ul>
<li>mSystemServiceManager.startService(JobShchedulerService.class); 启动服务</li>
<li>mSystemServiceManager.startBootPhase()设置启动phase相位，标记启动标识；</li>
</ul>
<p>等等这些方法，都由SystemServerManager管理者来处理；</p>
<p>在这之前，我们先来看SystemService.java </p>
<h3 id="（1）SystemService-java-是所有系统服务的逻辑父类"><a href="#（1）SystemService-java-是所有系统服务的逻辑父类" class="headerlink" title="（1）SystemService.java 是所有系统服务的逻辑父类"></a>（1）SystemService.java 是所有系统服务的逻辑父类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SystemService</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PHASE_WAIT_FOR_DEFAULT_DISPLAY</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// maybe should be a dependency?</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PHASE_LOCK_SETTINGS_READY</span> <span class="operator">=</span> <span class="number">480</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PHASE_SYSTEM_SERVICES_READY</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PHASE_ACTIVITY_MANAGER_READY</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PHASE_THIRD_PARTY_APPS_CAN_START</span> <span class="operator">=</span> <span class="number">600</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PHASE_BOOT_COMPLETED</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务启动生命周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接收当前相位的生命周期方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBootPhase</span><span class="params">(<span class="type">int</span> phase)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布到ServiceManager大管家</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">publishBinderService</span><span class="params">(String name, IBinder service,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> allowIsolated)</span> &#123;</span><br><span class="line">        ServiceManager.addService(name, service, allowIsolated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）SystemServiceManager管理所有服务，并调度SystemServer服务的onStart-、onBootPhase-生命周期方法"><a href="#（2）SystemServiceManager管理所有服务，并调度SystemServer服务的onStart-、onBootPhase-生命周期方法" class="headerlink" title="（2）SystemServiceManager管理所有服务，并调度SystemServer服务的onStart()、onBootPhase()生命周期方法"></a>（2）SystemServiceManager管理所有服务，并调度SystemServer服务的onStart()、onBootPhase()生命周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemServiceManager</span> &#123;</span><br><span class="line">    <span class="comment">//持有所有服务，并存储到list中，用于后续调度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;SystemService&gt; mServices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SystemService&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//启动服务</span></span><br><span class="line">    <span class="keyword">public</span> SystemService <span class="title function_">startService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//反射获取Service类</span></span><br><span class="line">            serviceClass = (Class&lt;SystemService&gt;)Class.forName(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续调用SystemServer.onStart()生命周期中</span></span><br><span class="line">        <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">SystemService</span>&gt; T <span class="title function_">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> serviceClass.getName();</span><br><span class="line">       <span class="keyword">final</span> T service;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">           service = constructor.newInstance(mContext);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 存储到数组中</span></span><br><span class="line">        mServices.add(service);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用生命周期方法</span></span><br><span class="line">            service.onStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用phase相位，标记当前服务启动到哪个阶段了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startBootPhase</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> phase)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">serviceLen</span> <span class="operator">=</span> mServices.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; serviceLen; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">SystemService</span> <span class="variable">service</span> <span class="operator">=</span> mServices.get(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用服务的生命周期方法</span></span><br><span class="line">                service.onBootPhase(mCurrentPhase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="（三）服务启动阶段各phase相位说明"><a href="#（三）服务启动阶段各phase相位说明" class="headerlink" title="（三）服务启动阶段各phase相位说明"></a>（三）服务启动阶段各phase相位说明</h2><p>SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程：</p>
<p>各阶段的大概位置如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SystemServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBootstrapServices</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//1、phase100</span></span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startCoreServices</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//2、phase480 &amp;&amp; 500</span></span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//AMS启动后调用至此的</span></span><br><span class="line">      mActivityManagerService.systemReady(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="comment">//3、phase550</span></span><br><span class="line">             mSystemServiceManager.startBootPhase(</span><br><span class="line">                     SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">             ...</span><br><span class="line">             <span class="comment">//4、phase600</span></span><br><span class="line">             mSystemServiceManager.startBootPhase(</span><br><span class="line">                     SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>左边蓝色区域是在各个phase相位之间做的操作，以调用顺序区分的；</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_10.jpg" alt="image.png"></p>
<blockquote>
<p>PHASE_BOOT_COMPLETED&#x3D;1000，该阶段是发生在Boot完成和home应用启动完毕。系统服务更倾向于监听该阶段，而不是注册广播ACTION_BOOT_COMPLETED，从而降低系统延迟。</p>
</blockquote>
<p>接下来再说说简单每个阶段的大概完成的工作：</p>
<h3 id="（1）Phase0"><a href="#（1）Phase0" class="headerlink" title="（1）Phase0"></a>（1）Phase0</h3><p>创建四大引导服务:</p>
<ul>
<li>ActivityManagerService</li>
<li>PowerManagerService</li>
<li>LightsService</li>
<li>DisplayManagerService</li>
</ul>
<h3 id="（2）Phase100"><a href="#（2）Phase100" class="headerlink" title="（2）Phase100"></a>（2）Phase100</h3><p>进入阶段PHASE_WAIT_FOR_DEFAULT_DISPLAY&#x3D;100回调服务</p>
<p>onBootPhase(100)</p>
<ul>
<li>DisplayManagerService</li>
</ul>
<p>然后创建大量服务下面列举部分:</p>
<ul>
<li>PackageManagerService</li>
<li>WindowManagerService</li>
<li>InputManagerService</li>
<li>NetworkManagerService</li>
<li>DropBoxManagerService</li>
<li>FingerprintService</li>
<li>LauncherAppsService</li>
</ul>
<h3 id="（3）Phase480"><a href="#（3）Phase480" class="headerlink" title="（3）Phase480"></a>（3）Phase480</h3><p>onBootPhase(480)</p>
<ul>
<li>DevicePolicyManagerService</li>
</ul>
<p>阶段480后马上就进入阶段500.</p>
<h3 id="（4）Phase500"><a href="#（4）Phase500" class="headerlink" title="（4）Phase500"></a>（4）Phase500</h3><p>onBootPhase(500)</p>
<ul>
<li>AlarmManagerService</li>
<li>JobSchedulerService</li>
<li>NotificationManagerService</li>
<li>BackupManagerService</li>
<li>UsageStatsService</li>
<li>DeviceIdleController</li>
<li>TrustManagerService</li>
<li>UiModeManagerService</li>
<li>BluetoothService</li>
<li>BluetoothManagerService</li>
<li>EthernetService</li>
<li>WifiP2pService</li>
<li>WifiScanningService</li>
<li>WifiService</li>
<li>RttService</li>
</ul>
<p>各大服务执行systemReady():</p>
<ul>
<li>WindowManagerService.systemReady():</li>
<li>PowerManagerService.systemReady():</li>
<li>PackageManagerService.systemReady():</li>
<li>DisplayManagerService.systemReady():</li>
<li>接下来就绪AMS.systemReady方法.</li>
</ul>
<h3 id="（5）Phase550"><a href="#（5）Phase550" class="headerlink" title="（5）Phase550"></a>（5）Phase550</h3><p>onBootPhase(550)</p>
<ul>
<li>MountService</li>
<li>TelecomLoaderService</li>
<li>UsbService</li>
<li>WebViewUpdateService</li>
<li>DockObserver</li>
<li>BatteryService</li>
</ul>
<p>接下来执行: (AMS启动native crash监控, 加载WebView，启动SystemUi等),如下</p>
<ul>
<li>mActivityManagerService.startObservingNativeCrashes();</li>
<li>WebViewFactory.prepareWebViewInSystemServer();</li>
<li>startSystemUi(context);</li>
<li>networkScoreF.systemReady();</li>
<li>networkManagementF.systemReady();</li>
<li>networkStatsF.systemReady();</li>
<li>networkPolicyF.systemReady();</li>
<li>connectivityF.systemReady();</li>
<li>audioServiceF.systemReady();</li>
<li>Watchdog.getInstance().start();</li>
</ul>
<h3 id="（6）Phase600"><a href="#（6）Phase600" class="headerlink" title="（6）Phase600"></a>（6）Phase600</h3><ul>
<li>JobSchedulerService</li>
<li>NotificationManagerService</li>
<li>BackupManagerService</li>
<li>AppWidgetService</li>
<li>GestureLauncherService</li>
<li>DreamManagerService</li>
<li>TrustManagerService</li>
<li>VoiceInteractionManagerService</li>
</ul>
<h3 id="（7）Phase1000"><a href="#（7）Phase1000" class="headerlink" title="（7）Phase1000"></a>（7）Phase1000</h3><p>在经过一系列流程，再调用AMS.finishBooting()时，则进入阶段Phase1000。</p>
<p>到此，系统服务启动阶段完成就绪，system_server进程启动完成则进入Looper.loop()状态，随时待命，等待消息队列MessageQueue中的消息到来，则马上进入执行状态。</p>
<h2 id="（四）以JobScheduler为例看流程"><a href="#（四）以JobScheduler为例看流程" class="headerlink" title="（四）以JobScheduler为例看流程"></a>（四）以JobScheduler为例看流程</h2><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_11.jpg" alt="SystemServer启动服务过程.png"><br>在每个分类的start**Services()方法中，会调用Service的生命周期方法</p>
<p>以startOtherServices()举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">()</span> &#123;</span><br><span class="line">    mSystemServiceManager.startService(JobSchedulerService.class);</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-JobSchdulerService等-onStart-生命周期方法"><a href="#4-1-JobSchdulerService等-onStart-生命周期方法" class="headerlink" title="4.1 JobSchdulerService等.onStart()生命周期方法"></a><span id="jump4_3_1"/>4.1 JobSchdulerService等.onStart()生命周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">SystemService</span>&gt; T <span class="title function_">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> serviceClass.getName();</span><br><span class="line">    <span class="keyword">final</span> T service;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">        service = constructor.newInstance(mContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-JobSchdulerService等-onBootPhase-生命周期方法"><a href="#4-2-JobSchdulerService等-onBootPhase-生命周期方法" class="headerlink" title="4.2 JobSchdulerService等.onBootPhase()生命周期方法"></a><span id="jump4_3_2"/>4.2 JobSchdulerService等.onBootPhase()生命周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#http:<span class="comment">//aospxref.com/android-6.0.1_r9/xref/frameworks/base/services/core/java/com/android/server/SystemServiceManager.java?fi=startBootPhase#startBootPhase</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startBootPhase</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> phase)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">serviceLen</span> <span class="operator">=</span> mServices.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; serviceLen; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SystemService</span> <span class="variable">service</span> <span class="operator">=</span> mServices.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.onBootPhase(mCurrentPhase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://gityuan.com/2016/02/13/android-zygote/">Gityuan Android系统启动-zygote篇
</a></li>
<li><a target="_blank" rel="noopener" href="https://gityuan.com/2016/03/26/app-process-create/">Gityuan zygote 进程创建流程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/37370c1d17fc">努比亚</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://irving18.github.io">王征</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://irving18.github.io/2024/07/08/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">https://irving18.github.io/2024/07/08/Framework%E7%B3%BB%E7%BB%9F%E7%AF%871-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://irving18.github.io" target="_blank">Android高级直通车</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E8%BF%9B%E9%98%B6/">Android进阶</a><a class="post-meta__tags" href="/tags/Framework/">Framework</a><a class="post-meta__tags" href="/tags/AMS/">AMS</a><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/">系统服务</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/09/Framework%E7%B3%BB%E7%BB%9F%E7%AF%872-ActivityManagerService(AMS)%E5%90%AF%E5%8A%A8%E7%AF%87/" title="Framework系统篇2-ActivityManagerService(AMS)启动篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Framework系统篇2-ActivityManagerService(AMS)启动篇</div></div><div class="info-2"><div class="info-item-1">[toc] 一、前述在【Fw-系统启动流程】中已经知道，SystemServer进程的run()方法：  1、startBootstrapServices(); 启动引导服务：AMS、PMS、PowerManagerServic 2、startCoreServices(); 启动核心服务：BatteryService 3、startOtherServices(); 启动其他服务：如WMS  这其中还会调用startBootPhase() 方法，  1、传入不同的phase [feɪz]...</div></div></div></a><a class="pagination-related" href="/2024/07/05/Framework%E5%BC%80%E7%AF%873-Binder%20%E6%9C%BA%E5%88%B6%EF%BC%9AC%E5%B1%82&amp;java%E5%B1%82/" title="Framework开篇3-Binder 机制：C层&amp;java层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Framework开篇3-Binder 机制：C层&java层</div></div><div class="info-2"><div class="info-item-1">目录 一、Binder c层、java层结构 1、c层结构：BnInterface(服务端)&#x2F;BpInterface(客户端)；BBinder(服务端)&#x2F;BpBinder(客户端) 2、java层结构：Binder、BinderProxy   二、Binder的初始化 1、Binder的c层初始化 2、关于Binder传递数据的大小限制 3、与驱动的通信 4、数据包装器：Parcel 5、Framework层的Binder线程管理   三、C++ Binder服务举例 1、本地实现：Native端，即服务端 2、服务发布到ServiceManager 3、远程接口：Proxy端，即提供给客户端使用的 4、服务的获取，客户端从ServiceManager获取   四、java Binder服务举例 五、完整通信流程 六、总结 1、简述binder启动和通信过程 2、Binder启动、通信时序图 3、Binder通信时的基础参数  ① 控制类协议：如注册成ServiceManager ②...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/09/Framework%E7%B3%BB%E7%BB%9F%E7%AF%872-ActivityManagerService(AMS)%E5%90%AF%E5%8A%A8%E7%AF%87/" title="Framework系统篇2-ActivityManagerService(AMS)启动篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="info-item-2">Framework系统篇2-ActivityManagerService(AMS)启动篇</div></div><div class="info-2"><div class="info-item-1">[toc] 一、前述在【Fw-系统启动流程】中已经知道，SystemServer进程的run()方法：  1、startBootstrapServices(); 启动引导服务：AMS、PMS、PowerManagerServic 2、startCoreServices(); 启动核心服务：BatteryService 3、startOtherServices(); 启动其他服务：如WMS  这其中还会调用startBootPhase() 方法，  1、传入不同的phase [feɪz]...</div></div></div></a><a class="pagination-related" href="/2024/07/10/Framework%E7%B3%BB%E7%BB%9F%E7%AF%873-ActivityManagerService(AMS)%EF%BC%9AActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B&%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F/" title="Framework系统篇3-ActivityManagerService(AMS)：Activity启动流程&amp;绘制顺序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-10</div><div class="info-item-2">Framework系统篇3-ActivityManagerService(AMS)：Activity启动流程&amp;绘制顺序</div></div><div class="info-2"><div class="info-item-1">目录 前述、简述系统启动流程  简图 tips 1、为什么和zygoet通信是Socket呢？ 2、如果是多线程操作时，fork会有问题？     一、Activity启动流程  （1）简化启动App的Activity的流程 （2）Activity整体启动过程   二、Zygoet fork进程  （1）runSelectLoop轮询 （2）fork进程 （3）handleChildProc 调用新进程初始化方法 （4）ActivityThread.main   三、Activity绘制流程  完整流程图 （1）handleLaunchActivity：Window创建 1、onAttach： window创建(即PhoneWindow) WindowManagerImpl创建，并持有mGlobal(即WindowManagerGlobal)   2、onCreate：DecorView创建   （2）handleResumeActivity：mGlobal.add() 0、先执行onResume()回调 1、mGlobal.add(decorview) 并创建root...</div></div></div></a><a class="pagination-related" href="/2024/07/16/Framework%E7%B3%BB%E7%BB%9F%E7%AF%874-WindowManagerService(WMS)2%EF%BC%9A%E5%90%AF%E5%8A%A8%E7%AF%87/" title="Framework系统篇4-WindowManagerService(WMS)2：启动篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-16</div><div class="info-item-2">Framework系统篇4-WindowManagerService(WMS)2：启动篇</div></div><div class="info-2"><div class="info-item-1">[toc] 一、概述（1）WMS、Surface、SurfaceFlinger关系WMS核心关系：  Surface: 代表画布 WMS: 添加window的过程主要功能是添加Surface,管理所有的Surface布局,以及Z轴排序问题; SurfaceFinger: 将Surface按次序混合并显示到物理屏幕上;  （2）WMS整体认识  一、WMS端： WMS继承于IWindowManager.Stub, 作为Binder服务端; WMS的成员变量mSessions保存着所有的Session对象,Session继承于IWindowSession.Stub, 作为Binder服务端; 成员变量mPolicy: 实例对象为PhoneWindowManager,用于实现各种窗口相关的策略; 成员变量mChoreographer: 用于控制窗口动画,屏幕旋转等操作; 成员变量mDisplayContents: 记录一组DisplayContent对象,这个跟多屏输出相关; 成员变量mTokenMap: 保存所有的WindowToken对象;...</div></div></div></a><a class="pagination-related" href="/2024/07/14/Framework%E7%B3%BB%E7%BB%9F%E7%AF%874-WindowManagerService(WMS)1%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86+%E6%A6%82%E5%BF%B5/" title="Framework系统篇4-WindowManagerService(WMS)1：整体认识+概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-14</div><div class="info-item-2">Framework系统篇4-WindowManagerService(WMS)1：整体认识+概念</div></div><div class="info-2"><div class="info-item-1">[toc] 一、WMS作用的整体认知  1、首先WMS在启动之后会设置给AMS，也就是AMS会持有WMS的实例，方便后续调用 2、WMS内部 通过WindowManager管理WindowState，即Window的状态等； 通过WindowAnimator处理动画   3、和InputManagerService进行交互，处理输入事件dispatchTouchEvent() 分发触摸事件 4、通过SurfaceControl去SurfaceFlinger中申请Surface空间，将Surface返回给App进程，并管理Surface画布，通过Z轴混合后上帧给SurfaceFlinger进行渲染；  二、WMS中成员变量的作用 一、WMS端： WMS继承于IWindowManager.Stub, 作为Binder服务端; WMS的成员变量mSessions保存着所有的Session对象,Session继承于IWindowSession.Stub, 作为Binder服务端; 成员变量mPolicy:...</div></div></div></a><a class="pagination-related" href="/2024/07/18/Framework%E7%B3%BB%E7%BB%9F%E7%AF%874-WindowManagerService(WMS)3%EF%BC%9A%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="Framework系统篇4-WindowManagerService(WMS)3：启动窗口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="info-item-2">Framework系统篇4-WindowManagerService(WMS)3：启动窗口</div></div><div class="info-2"><div class="info-item-1">[toc] https://gityuan.com/2017/01/15/wms_starting_window/ 一、捋清一些概念（1）Activity、window、WindowState、windowToken、IApplicationToken的关系？1、IApplicationToken是进程独有的 在AMS启动Activity时startProcessLocked()，创建进程后attachApplication()时传给AMS的 是个Binder对象，用来跨进程通信的 会被存储在ActivityRecord.appToken中；  2、Activity和windowToken是一对多的 主窗口和 Activity：对于每个 Activity，当它的主窗口创建时，会有一个与该 Activity 相关的 windowToken。这个 windowToken 可以被认为与 Activity 一一对应，因为每个 Activity 的主窗口有且只有一个 windowToken。  子窗口（如 Dialog、PopupWindow 等）：一个 Activity...</div></div></div></a><a class="pagination-related" href="/2024/07/12/Framework%E7%B3%BB%E7%BB%9F%E7%AF%874-WindowManagerService(WMS)%EF%BC%9AWindow%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AF%87/" title="Framework系统篇4-WindowManagerService(WMS)：Window的使用篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-12</div><div class="info-item-2">Framework系统篇4-WindowManagerService(WMS)：Window的使用篇</div></div><div class="info-2"><div class="info-item-1">[toc] 一、Window和WindowManager、WMS的关系 window:它是一个抽象类，具体实现类为 PhoneWindow ，它对 View 进行管理。Window是View的容器，View是Window的具体表现内容； windowManager:是一个接口类，继承自接口 ViewManager ，从它的名称就知道它是用来管理 Window 的，它的实现类为 WindowManagerImpl； WMS:是窗口的管理者，它负责窗口的启动、添加和删除。另外窗口的大小和层级也是由它进行管理的；   二、Window的分类：LayoutParams.type 属性    分类 说明 是否需要权限    Application Window(应用窗口) 例如Activity；【取值范围为1~99】 -   Sub Window(子窗口) 不能独立存在，需要依附在其他窗口，例如PopupWindow，Dialog【取值范围为1000~1999】 -   System...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">王征</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IRVING18"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:ivring18@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><span>Android开发者迈向<span style="color:red; weight:bold" >高级Android开发</span>的直通车，总结了各大面试考点！<span></br><span>一个通人性的博主，码字不易，用爱发电。希望大家多多支持。</span><img width="250px" src="/img/wechat_pay.png"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%85%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">一、系统启动入口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89init-rc%EF%BC%9A%E6%A0%87%E8%AF%86core%E3%80%81main%E3%80%81late-start%E7%B1%BB%E5%9E%8B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">（一）init.rc：标识core、main、late_start类型服务 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B3%BB%E7%BB%9F%E4%B8%BB%E5%87%BD%E6%95%B0-init-cpp%EF%BC%9A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8Fcore-main-late-start"><span class="toc-number">1.2.</span> <span class="toc-text">（二）系统主函数 init.cpp：执行顺序core &gt; main &gt; late_start</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81core%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、core类型的服务进程是怎么执行的呢？ </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%82%A3%E4%B9%88main%E3%80%81late-start%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%93%AA%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、那么main、late_start类型的服务进程在哪执行的呢？ </span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Servicemanager%E5%90%AF%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">二、Servicemanager启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89ServiceManager%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">（一）ServiceManager主函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89svcinfo%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%AD%98%E5%82%A8%E6%B3%A8%E5%86%8C%E8%BF%9B%E6%9D%A5%E7%9A%84Binder%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E4%BD%93"><span class="toc-number">2.2.</span> <span class="toc-text">（二）svcinfo结构体，存储注册进来的Binder服务的实体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89ServiceManager%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7%EF%BC%9AdefaultServiceManager"><span class="toc-number">2.3.</span> <span class="toc-text">（三）ServiceManager进程的特殊性：defaultServiceManager</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Zygoet%E5%90%AF%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">三、Zygoet启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Zygoet%E5%AE%8C%E6%95%B4%E5%90%AF%E5%8A%A8%E5%9B%BE%EF%BC%9Ac-java"><span class="toc-number">3.1.</span> <span class="toc-text">（一）Zygoet完整启动图：c-&gt;java</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89c%E5%B1%82"><span class="toc-number">3.2.</span> <span class="toc-text">（二）c层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89c%E5%B1%82%E4%B8%BB%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3app-main-main"><span class="toc-number">3.2.1.</span> <span class="toc-text">（1）c层主函数入口app_main.main</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89AppRuntime-start"><span class="toc-number">3.2.2.</span> <span class="toc-text">（2）AppRuntime::start()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89java%E5%B1%82"><span class="toc-number">3.3.</span> <span class="toc-text">（三）java层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89java%E5%B1%82%E4%B8%BB%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3ZygoteInit-main"><span class="toc-number">3.3.1.</span> <span class="toc-text">（1）java层主函数入口ZygoteInit.main</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89registerZygoteSocket%EF%BC%9A%E5%BC%80%E5%90%AFSocket%E9%80%9A%E4%BF%A1"><span class="toc-number">3.3.2.</span> <span class="toc-text">（2）registerZygoteSocket：开启Socket通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89preload-CopyOnWrite%E6%96%B9%E5%BC%8F%EF%BC%88fork%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">（3）preload &amp; CopyOnWrite方式（fork进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89startSystemServer-%EF%BC%88fork-system-server%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">（4）startSystemServer （fork system_server进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89runSelectLoop%EF%BC%9A%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E5%91%BD%E4%BB%A4%E8%B0%83%E7%94%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">（5）runSelectLoop：无限循环等待创建进程命令调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89runOnce-fork%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%E6%96%B0%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.6.</span> <span class="toc-text">（6）runOnce fork进程，并调用新进程初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Zygoet%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%B0%8F%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">（四）Zygoet启动流程小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89runOnce-fork%E8%BF%9B%E7%A8%8B%E8%AF%A6%E6%83%85"><span class="toc-number">3.5.</span> <span class="toc-text">（五）runOnce fork进程详情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89java%E5%B1%82%EF%BC%9AforkAndSpecialize"><span class="toc-number">3.5.1.</span> <span class="toc-text">（1）java层：forkAndSpecialize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89c%E5%B1%82%EF%BC%9AnativeForkAndSpecialize"><span class="toc-number">3.5.2.</span> <span class="toc-text">（2）c层：nativeForkAndSpecialize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89c%E5%B1%82%EF%BC%9Afork"><span class="toc-number">3.5.3.</span> <span class="toc-text">（3）c层：fork()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E6%96%B0%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-number">3.6.</span> <span class="toc-text">（六）新进程运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89handleChildProc"><span class="toc-number">3.6.1.</span> <span class="toc-text">（1）handleChildProc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89zygoteInit-%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">（2）zygoteInit 调度方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89applicationInit"><span class="toc-number">3.6.3.</span> <span class="toc-text">（3）applicationInit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89invokeStaticMain"><span class="toc-number">3.6.4.</span> <span class="toc-text">（4）invokeStaticMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89MethodAndArgsCaller"><span class="toc-number">3.6.5.</span> <span class="toc-text">（5）MethodAndArgsCaller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89ActivityThread-main"><span class="toc-number">3.6.6.</span> <span class="toc-text">（6）ActivityThread.main</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89Zygoet-fork%E8%BF%9B%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.7.</span> <span class="toc-text">（七）Zygoet fork进程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81system-server%E5%90%AF%E5%8A%A8"><span class="toc-number">4.</span> <span class="toc-text">四、system_server启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89SystemServer%E5%90%AF%E5%8A%A8"><span class="toc-number">4.1.</span> <span class="toc-text">（一）SystemServer启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89SystemServer%E7%94%B1Zygoet-fork%E5%90%AF%E5%8A%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">（1）SystemServer由Zygoet fork启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89SystemServer-main"><span class="toc-number">4.1.2.</span> <span class="toc-text">（2）SystemServer.main()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89SystemServer-run-%EF%BC%8C%E8%B0%83%E5%BA%A6AMS%E3%80%81PMS%E7%AD%89%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.3.</span> <span class="toc-text">（3）SystemServer.run()，调度AMS、PMS等其他系统服务，分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%88%E6%9D%A5%E8%AE%A4%E8%AF%86SystemServiceManager-%E7%AE%A1%E7%90%86%E8%80%85"><span class="toc-number">4.2.</span> <span class="toc-text">（二）先来认识SystemServiceManager 管理者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89SystemService-java-%E6%98%AF%E6%89%80%E6%9C%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%80%BB%E8%BE%91%E7%88%B6%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text">（1）SystemService.java 是所有系统服务的逻辑父类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89SystemServiceManager%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%B9%B6%E8%B0%83%E5%BA%A6SystemServer%E6%9C%8D%E5%8A%A1%E7%9A%84onStart-%E3%80%81onBootPhase-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">（2）SystemServiceManager管理所有服务，并调度SystemServer服务的onStart()、onBootPhase()生命周期方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%90%84phase%E7%9B%B8%E4%BD%8D%E8%AF%B4%E6%98%8E"><span class="toc-number">4.3.</span> <span class="toc-text">（三）服务启动阶段各phase相位说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Phase0"><span class="toc-number">4.3.1.</span> <span class="toc-text">（1）Phase0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Phase100"><span class="toc-number">4.3.2.</span> <span class="toc-text">（2）Phase100</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Phase480"><span class="toc-number">4.3.3.</span> <span class="toc-text">（3）Phase480</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89Phase500"><span class="toc-number">4.3.4.</span> <span class="toc-text">（4）Phase500</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89Phase550"><span class="toc-number">4.3.5.</span> <span class="toc-text">（5）Phase550</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89Phase600"><span class="toc-number">4.3.6.</span> <span class="toc-text">（6）Phase600</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89Phase1000"><span class="toc-number">4.3.7.</span> <span class="toc-text">（7）Phase1000</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BB%A5JobScheduler%E4%B8%BA%E4%BE%8B%E7%9C%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">（四）以JobScheduler为例看流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-JobSchdulerService%E7%AD%89-onStart-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.1 JobSchdulerService等.onStart()生命周期方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-JobSchdulerService%E7%AD%89-onBootPhase-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.2 JobSchdulerService等.onBootPhase()生命周期方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/20/Framework%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AF%87-Service%EF%BC%9AstartService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Framework四大组件篇-Service：startService源码分析">Framework四大组件篇-Service：startService源码分析</a><time datetime="2024-09-20T07:40:47.000Z" title="发表于 2024-09-20 15:40:47">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/17/Framework%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AF%87-Service%EF%BC%9AbindService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Framework四大组件篇-Service：bindService源码分析">Framework四大组件篇-Service：bindService源码分析</a><time datetime="2024-09-17T07:40:36.000Z" title="发表于 2024-09-17 15:40:36">2024-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/16/Framework%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AF%87-Service1%E4%BD%BF%E7%94%A8%E7%AF%87/" title="Framework四大组件篇-Service1使用篇">Framework四大组件篇-Service1使用篇</a><time datetime="2024-09-16T07:40:35.000Z" title="发表于 2024-09-16 15:40:35">2024-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/Framework%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AF%87-ContentProvider%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Framework四大组件篇-ContentProvider启动源码分析">Framework四大组件篇-ContentProvider启动源码分析</a><time datetime="2024-09-07T07:39:36.000Z" title="发表于 2024-09-07 15:39:36">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/30/Framework%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AF%87-BroadCast%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Framework四大组件篇-BroadCast原理源码分析">Framework四大组件篇-BroadCast原理源码分析</a><time datetime="2024-08-30T07:40:05.000Z" title="发表于 2024-08-30 15:40:05">2024-08-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.png);"><div id="footer-wrap"><div class="copyright">&copy;2024 By 王征</div><div class="footer_custom_text"><a href=""><img class="icp-icon" src="/img/avatar.jpg"><span>一个通人性的博主</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>