<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线程-1-基础-TODO | 一个通人性的博主</title><meta name="author" content="王征"><meta name="copyright" content="王征"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="todo-list:1、阿里三问https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;fa9a92f517db 目录 一、线程 1、创建线程的方式：理论上只有两种 2、线程状态简版：新建、就绪、阻塞、结束 3、线程状态完整：1、NEW（初始）；2、RUNNING（运行中）&#x2F;READY（就绪）；3、WAITING（等待）；4、TIMED_WAITING(等待超时)；5、BLOCKED（阻塞）">
<meta property="og:type" content="article">
<meta property="og:title" content="线程-1-基础-TODO">
<meta property="og:url" content="https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO/index.html">
<meta property="og:site_name" content="一个通人性的博主">
<meta property="og:description" content="todo-list:1、阿里三问https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;fa9a92f517db 目录 一、线程 1、创建线程的方式：理论上只有两种 2、线程状态简版：新建、就绪、阻塞、结束 3、线程状态完整：1、NEW（初始）；2、RUNNING（运行中）&#x2F;READY（就绪）；3、WAITING（等待）；4、TIMED_WAITING(等待超时)；5、BLOCKED（阻塞）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://irving18.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-12-27T03:44:54.000Z">
<meta property="article:modified_time" content="2024-12-27T03:46:29.128Z">
<meta property="article:author" content="王征">
<meta property="article:tag" content="JAVA基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://irving18.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程-1-基础-TODO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">一个通人性的博主</span></a><a class="nav-page-title" href="/"><span class="site-name">线程-1-基础-TODO</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">线程-1-基础-TODO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-27T03:44:54.000Z" title="发表于 2024-12-27 11:44:54">2024-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-27T03:46:29.128Z" title="更新于 2024-12-27 11:46:29">2024-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>todo-list:<br>1、阿里三问<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fa9a92f517db">https://www.jianshu.com/p/fa9a92f517db</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#jump1">一、线程</a><ul>
<li><a href="#jump10">1、创建线程的方式：理论上只有两种</a></li>
<li><a href="#jump11">2、线程状态简版：新建、就绪、阻塞、结束</a></li>
<li><a href="#jump12">3、线程状态完整：1、NEW（初始）；2、RUNNING（运行中）&#x2F;READY（就绪）；3、WAITING（等待）；4、TIMED_WAITING(等待超时)；5、BLOCKED（阻塞）；6、TERMINATED（终止）</a></li>
</ul>
</li>
<li><a href="#jump2">二、线程的API</a><ul>
<li><a href="#jump21">1、静态方法</a><ul>
<li><a href="#jump211">1.1、Thread.yield()</a></li>
<li><a href="#jump212">1.2、Thread.sleep() </a><ul>
<li><a href="#jump212">&lt;1&gt; 抛出InterruptedException时机</a></li>
<li><a href="#jump212">&lt;2&gt; interrupted标志清除时机</a></li>
<li><a href="#jump212">&lt;3&gt; 和wait()的区别</a></li>
</ul>
</li>
<li><a href="#jump213">1.3、Thread.interrupted()</a></li>
</ul>
</li>
<li><a href="#jump">2、普通方法</a><ul>
<li><a href="#jump">2.1、new Thread().start()</a></li>
<li><a href="#jump">2.2、new Thread().run()</a></li>
<li><a href="#jump">2.3、new Thread().join()</a></li>
<li><a href="#jump">2.4、new Thread().setDaemon()</a></li>
<li><a href="#jump">2.5、new Thread().setPriority()</a></li>
<li><a href="#jump">2.6、new Thread().stop()</a></li>
<li><a href="#jump">2.7、new Thread().interrupt()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jump3">三、线程锁</a><ul>
<li><a href="#jump3">1、synchronized 隐式锁</a></li>
<li><a href="#jump3">2、Lock显示锁</a></li>
<li><a href="#jump3">3、类锁、对象锁</a></li>
</ul>
</li>
<li><a href="#jump4">四、线程锁的API -&gt; 必须有锁才能调用</a><ul>
<li><a href="#jump41">1、Object锁Api</a></li>
<li><a href="#jump42">2、Lock锁APi</a></li>
</ul>
</li>
<li><a href="#jump5">五、死锁</a><ul>
<li><a href="#jump5">死锁的定义 &amp; 资源的分类</a></li>
<li><a href="#jump51">1、死锁的四大必要条件</a></li>
<li><a href="#jump52">2、死锁的预防</a></li>
<li><a href="#jump53">3、死锁的避免</a></li>
<li><a href="#jump54">4、死锁预防、死锁避免的区别</a></li>
</ul>
</li>
</ul>
<h2 id="一、线程状态-转换"><a href="#一、线程状态-转换" class="headerlink" title="一、线程状态-转换"></a><font id="jump1">一、线程状态-转换</h2><h3 id="1、创建线程的方式：理论上只有两种"><a href="#1、创建线程的方式：理论上只有两种" class="headerlink" title="1、创建线程的方式：理论上只有两种"></a><font id="jump10">1、创建线程的方式：理论上只有两种</h3><h4 id="1-extends-Thread-实现run方法"><a href="#1-extends-Thread-实现run方法" class="headerlink" title="(1) extends Thread 实现run方法"></a>(1) extends Thread 实现run方法</h4><h4 id="2-创建runnable，传入Thread-构造方法"><a href="#2-创建runnable，传入Thread-构造方法" class="headerlink" title="(2) 创建runnable，传入Thread()构造方法"></a>(2) 创建runnable，传入Thread()构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">newThreadTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、重写Thread的run方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">    <span class="comment">//2、传入Runnable对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//3、callable方式：</span></span><br><span class="line">    <span class="comment">// 3.1 实际上还是Runnable。因为FutureTask是继承Runnable的。</span></span><br><span class="line">    <span class="comment">// 3.2 而却Thread的构造方法，都必须传Runnable类型的，没有其他的</span></span><br><span class="line">    Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(callable)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、简版"><a href="#2、简版" class="headerlink" title="2、简版"></a><font id="jump11">2、简版</h3><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO_1.jpg" alt="Thread状态装换图"></p>
<h3 id="3、完整版"><a href="#3、完整版" class="headerlink" title="3、完整版"></a><font id="jump12">3、完整版</h3><table>
<thead>
<tr>
<th>Thread状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1、NEW（初始）</td>
<td>-</td>
</tr>
<tr>
<td>2、RUNNING（运行中）&#x2F;READY（就绪）</td>
<td>1、start之后且没有资源竞争时就进入，<p>2、RUNNING和READY切换是根据CPU执行时间片决定</td>
</tr>
<tr>
<td>3、WAITING（等待）</td>
<td>Object.wait()、Condition.await()、Lock.lock()竞争锁会进入</td>
</tr>
<tr>
<td>4、TIMED_WAITING(等待超时)</td>
<td>Object.wait(long)、Condition.await(long)、Lock.lock(long,TimeUint)竞争锁会进入</td>
</tr>
<tr>
<td>5、BLOCKED（阻塞）</td>
<td>只有synchronized竞争锁时会进入</td>
</tr>
<tr>
<td>6、TERMINATED（终止）</td>
<td>运行结束</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO_2.jpg" alt="Thread\_状态图\_完整"></p>
<h2 id="二、线程的API"><a href="#二、线程的API" class="headerlink" title="二、线程的API"></a><font id="jump2">二、线程的API</h2><h3 id="1、静态方法"><a href="#1、静态方法" class="headerlink" title="1、静态方法"></a><font id="jump21">1、静态方法</h3><h4 id="1-1、Thread-yield"><a href="#1-1、Thread-yield" class="headerlink" title="1.1、Thread.yield()"></a><font id="jump211">1.1、Thread.yield()</h4><p>让出当前线程时间片，让cpu去执行其他线程。</p>
<h4 id="1-2、Thread-sleep"><a href="#1-2、Thread-sleep" class="headerlink" title="1.2、Thread.sleep()"></a><font id="jump212">1.2、Thread.sleep()</h4><ul>
<li><p>&lt;1&gt; sleep()时外部调用interrupt()方法，会抛出InterruptedException</p>
</li>
<li><p>&lt;2&gt; sleep()抛出InterruptedException，会将isInterrupted状态重置，</p>
<p>所以若需要配合interrupt()方法，需要再catch中去停止任务。否则线程不会停止。</p>
</li>
<li><p>&lt;3&gt; sleep()和wait()的区别？</p>
<ul>
<li>1、sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。</li>
<li>2、sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)。</li>
<li>3、它们都可以被interrupted方法中断。</li>
</ul>
</li>
</ul>
<h4 id="1-3、Thread-interrupted"><a href="#1-3、Thread-interrupted" class="headerlink" title="1.3、Thread.interrupted()"></a><font id="jump213">1.3、Thread.interrupted()</h4><p>用于判断当前线程是否处于interrupted()状态，注意区别于普通成员方法new Thread().interrupt();</p>
<h3 id="2、普通成员方法"><a href="#2、普通成员方法" class="headerlink" title="2、普通成员方法"></a><font id="jump22">2、普通成员方法</h3><h4 id="2-1、new-Thread-start"><a href="#2-1、new-Thread-start" class="headerlink" title="2.1、new Thread().start()"></a>2.1、new Thread().start()</h4><h4 id="2-2、new-Thread-run"><a href="#2-2、new-Thread-run" class="headerlink" title="2.2、new Thread().run()"></a>2.2、new Thread().run()</h4><p>start才是启动线程，run()是直接在当前线程运行rannable的run方法。</p>
<h4 id="2-3、new-Thread-join-join-long-millis-join-long-millis-int-nanos"><a href="#2-3、new-Thread-join-join-long-millis-join-long-millis-int-nanos" class="headerlink" title="2.3、new Thread().join()&#x2F;join(long millis)&#x2F;join(long millis, int nanos)"></a>2.3、new Thread().join()&#x2F;join(long millis)&#x2F;join(long millis, int nanos)</h4><ul>
<li>(1) Join方法实现是通过wait（小提示：Object 提供的方法）。 当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁),调用该对象的wait(等待时间)，直到该对象唤醒main线程 ，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。</li>
<li>(2) join()用到了wait()所以会抛出InterruptedException</li>
<li>(3) 三个方法都被final修饰，无法被子类重写。</li>
<li>(4) join() 和 join(0) 是等价的，表示一直等下去；join(非0)表示等待一段时间。<br>从源码可以看到 join(0) 调用了Object.wait(0)，其中Object.wait(0) 会一直等待，直到被notify&#x2F;中断才返回。<br>while(isAlive())是为了防止子线程伪唤醒(spurious wakeup)，只要子线程没有TERMINATED的，父线程就需要继续等下去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4、new-Thread-setDaemon"><a href="#2-4、new-Thread-setDaemon" class="headerlink" title="2.4、new Thread().setDaemon()"></a>2.4、new Thread().setDaemon()</h4><p>设置守护线程</p>
<ul>
<li>如果不设置：主线程不会结束，会一直等待daemonThread执行。</li>
<li>只能在start()之前设置，否则会抛出java.lang.IllegalThreadStateException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;守护线程：&quot;</span> + i++);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//跳出循环，不再执行循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//设置daemonThread为主线程的守护线程。</span></span><br><span class="line">    <span class="comment">//如果不设置：主线程不会结束，会一直等待daemonThread执行。</span></span><br><span class="line">    <span class="comment">//只能在start()之前设置，否则会抛出java.lang.IllegalThreadStateException</span></span><br><span class="line">    daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5、new-Thread-setPriority"><a href="#2-5、new-Thread-setPriority" class="headerlink" title="2.5、new Thread().setPriority()"></a>2.5、new Thread().setPriority()</h4><p>用于设置更改线程的优先级。每个线程都有一个优先级，由1到10之间的整数表示。</p>
<p>Thread类提供3个常量属性:</p>
<ul>
<li>public static int MIN_PRIORITY:它是线程的最大优先级，它的值是1。</li>
<li>public static int NORM_PRIORITY:这是线程的普通优先级，它的值是5。</li>
<li>public static int MAX_PRIORITY:它是线程的最小优先级，它的值是10。</li>
</ul>
<h4 id="2-6、new-Thread-stop"><a href="#2-6、new-Thread-stop" class="headerlink" title="2.6、new Thread().stop()"></a>2.6、new Thread().stop()</h4><p>强制停止Thread，已经被废弃</p>
<h4 id="2-7、new-Thread-interrupt"><a href="#2-7、new-Thread-interrupt" class="headerlink" title="2.7、new Thread().interrupt()"></a>2.7、new Thread().interrupt()</h4><p>设置Thread的interrupted状态。</p>
<ul>
<li>给处于sleep&#x2F;wait&#x2F;join状态中的线程调用，interrupt()方法，会抛出InterruptedException</li>
<li>catch InterruptedException 异常的同时会重置interrupted状态。</li>
</ul>
<h2 id="三、线程锁"><a href="#三、线程锁" class="headerlink" title="三、线程锁"></a><font id="jump3">三、线程锁</h2><h3 id="1、synchronized-隐式锁"><a href="#1、synchronized-隐式锁" class="headerlink" title="1、synchronized 隐式锁"></a>1、synchronized 隐式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐式锁：对象锁，Test.this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//this对象锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testA2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通对象锁</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testA3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐式锁：类锁，Test.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Lock显示锁"><a href="#2、Lock显示锁" class="headerlink" title="2、Lock显示锁"></a>2、Lock显示锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、类锁、对象锁"><a href="#3、类锁、对象锁" class="headerlink" title="3、类锁、对象锁"></a>3、类锁、对象锁</h3><p>如上例子，</p>
<p>类锁就是以类的class字节码作为锁。</p>
<p>对象锁就是以对象作为锁。</p>
<h2 id="四、线程锁的API-必须有锁才能调用"><a href="#四、线程锁的API-必须有锁才能调用" class="headerlink" title="四、线程锁的API -&gt; 必须有锁才能调用"></a><font id="jump4">四、线程锁的API -&gt; 必须有锁才能调用</h2><blockquote>
<p>1、只有synchronized产生锁竞争的时候Thread才会进入阻塞状态。<br>2、lock.lock()产生锁竞争的时候Thread进入的是waiting&#x2F;time_waiting状态</p>
</blockquote>
<h3 id="1、Object锁Api"><a href="#1、Object锁Api" class="headerlink" title="1、Object锁Api"></a><font id="jump41">1、Object锁Api</h3><table>
<thead>
<tr>
<th>Object锁方法名</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>notify()</td>
<td>唤起<font color="RED">一个</font>正在<font color="RED">等待当前锁</font>的<font color="RED">wait</font>状态的Thread</td>
<td>相对锁来说的，调用锁的notify&#x2F;notifyAll方法。</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤起<font color="RED">所有</font>正在<font color="RED">等待当前锁</font>的<font color="RED">wait</font>状态的Thread</td>
<td>相对锁来说的，调用锁的notify&#x2F;notifyAll方法。</td>
</tr>
<tr>
<td>wait()</td>
<td>进入wait状态，释放锁</td>
<td><p>1、相对锁来说，调用锁的wait方法。<p> 2、调用的不是当前锁的wait，会抛出异常IllegalMonitorStateException</td>
</tr>
</tbody></table>
<p>注意如下情况：调用的不是当前锁的wait，就会报错了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCustomerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">                <span class="keyword">synchronized</span> (ProducerCustomerTest.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        <span class="comment">//notify() wait()操作都是相对于锁来说的，所以需要调用锁的notify/wait</span></span><br><span class="line">                        <span class="comment">//唤醒一个其他需要ProducerCustomerTest.class锁的线程</span></span><br><span class="line">                        <span class="comment">//  如果直接调用notify调用的是当前匿名内部类Thread的notify，</span></span><br><span class="line">                        <span class="comment">//  和我们使用的ProducerCustomerTest.class锁不是同一把锁，就会报错抛出java.lang.IllegalMonitorStateException</span></span><br><span class="line">                        <span class="comment">//notify()</span></span><br><span class="line">                        ProducerCustomerTest.class.notify();</span><br><span class="line">                        <span class="comment">//消费一个就等待,wait()会释放锁</span></span><br><span class="line">                        ProducerCustomerTest.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Lock锁APi"><a href="#2、Lock锁APi" class="headerlink" title="2、Lock锁APi"></a><font id="jump42">2、Lock锁APi</h3><table>
<thead>
<tr>
<th>Lock锁方法名</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>lock.lock();</td>
<td>加锁</td>
<td>1、未获取到时进入wait状态 <p> 2、不受interrupt()影响，仍会继续在wait状态</td>
</tr>
<tr>
<td>lock.unlock();</td>
<td>释放锁</td>
<td>-</td>
</tr>
<tr>
<td>lock.tryLock();</td>
<td>尝试获取锁，true：获取 false：未获取</td>
<td>未获取到时会释放资源，不会进入wait状态</td>
</tr>
<tr>
<td>lock.lockInterruptibly();</td>
<td>可监听InterruptedException异常的加锁。</td>
<td>1、先判断Thread是否在interrupted状态，如果在会直接抛出异常 <p> 2、阻塞状态中，可通过interrupt()抛出异常停止wait状态</td>
</tr>
<tr>
<td>Condition condition &#x3D; lock.newCondition();</td>
<td>获取当前lock的condition对象</td>
<td></td>
</tr>
<tr>
<td>condition.await();</td>
<td>类似object.wait()方法</td>
<td>设置当前锁让出资源，Thread进入wait状态</td>
</tr>
<tr>
<td>condition.await(long,TimeUnit)</td>
<td>可设置等待时间</td>
<td>-</td>
</tr>
<tr>
<td>condition.awaitUntil(Date);</td>
<td>可设置等待日期</td>
<td>-</td>
</tr>
<tr>
<td>condition.signal();</td>
<td>类似Object.notify()</td>
<td>唤起一个等待当前锁的线程</td>
</tr>
<tr>
<td>condition.signalAll();</td>
<td>类似Object.notifyAll()</td>
<td>唤起所有等待当前锁的线程</td>
</tr>
</tbody></table>
<h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a><font id="jump5">五、死锁</h2><p><font color="red">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</font>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<h3 id="资源的分类"><a href="#资源的分类" class="headerlink" title="资源的分类"></a>资源的分类</h3><p>系统中的资源可以分为两类：</p>
<ul>
<li><font color="red">可剥夺资源</font>，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li><font color="red">不可剥夺资源</font>，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ul>
<p><font color="red">产生死锁中的竞争资源之一指的是竞争不可剥夺资源</font></p>
<p>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
<p><font color="red">产生死锁中的竞争资源另外一种资源指的是竞争临时资源</font></p>
<p>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁。</p>
<h3 id="1、死锁的四大必要条件"><a href="#1、死锁的四大必要条件" class="headerlink" title="1、死锁的四大必要条件"></a><font id="jump51">1、死锁的四大必要条件</h3><ul>
<li><font color="red">互斥条件：</font>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li><font color="red">不可剥夺条件：</font>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><font color="red">请求和保持条件：</font>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li><font color="red">环路等待条件：</font>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、互斥条件，synchronized锁资源本身是互斥锁</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">oA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">                <span class="comment">//2、不可剥夺条件，synchronized获取到锁只能主动释放</span></span><br><span class="line">                <span class="keyword">synchronized</span> (oA) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取oA 锁&quot;</span>);</span><br><span class="line">                    <span class="comment">//3、请求和保持条件，请求oB锁，并不会释放oA锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (oB) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取所有资源，可以工作了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (oB) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//4、触发环路等待，Thread-0获取oA，Thread-1获取oB。Thread-0释放oA的条件是先获取oB。Thread-1释放oB的条件是先获取oA。</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取oB 锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (oA) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取所有资源，可以工作了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、死锁的预防"><a href="#2、死锁的预防" class="headerlink" title="2、死锁的预防"></a><font id="jump52">2、死锁的预防</h3><p>破坏构成死锁的四大必要条件，可能会导致系统资源利用率和系统吞吐量降低：</p>
<ul>
<li><font color="red">打破互斥条件</font>：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li><font color="red">打破不可剥夺条件</font>：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li><font color="red">打破请求和保持条件</font>：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li><font color="red">打破环路等待条件</font>：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
</ul>
<h3 id="3、死锁的避免"><a href="#3、死锁的避免" class="headerlink" title="3、死锁的避免"></a><font id="jump53">3、死锁的避免</h3><p>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。</p>
<h3 id="4、死锁预防、死锁避免的区别"><a href="#4、死锁预防、死锁避免的区别" class="headerlink" title="4、死锁预防、死锁避免的区别"></a><font id="jump54">4、死锁预防、死锁避免的区别</h3><p>预防死锁所施加的限制条件较严格，可能会导致系统资源利用率和系统吞吐量降低。（设置某些条件，去破坏产生死锁的四个必要条件中的一个或几个）</p>
<p>避免死锁所施加限制条件较宽松，可获得较高的资源利用率和系统吞吐量，有利于进程的并发执行。（在资源的动态分配过程中，用某种方法去防止系统进入不安全状态）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://irving18.github.io">王征</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO/">https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://irving18.github.io" target="_blank">一个通人性的博主</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-4-ThreadLocal/" title="线程-4-ThreadLocal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">线程-4-ThreadLocal</div></div><div class="info-2"><div class="info-item-1">ThreadLocal 一、出现原因、解决什么问题?     1、出现原因：高效保证线程安全的数据  2、ThreadLocal的作用   二、用途场景，使用示例 三、原理、源码分析 THreadLocal原理  1、Thread源码：持有存储键值对的成员变量threadLocals  2、ThreadLocalMap源码：存储键值对的类  3、ThreadLocal源码：对外暴露get()&#x2F;set()方法等   四、Hash冲突 1、ThreadLocal的hash算法？ 2、hash冲突的解决方案？ 3、ThreadLocalMap的扩容规则   五、内存泄露原因？解决方案？ 六、为什么有内存泄露风险，JDK仍然这么设计呢？  一、出现原因、解决什么问题?...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-AQS-ReentranLock%E7%BA%BF%E7%A8%8B%E9%94%81/" title="线程-2-AQS-ReentranLock线程锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">线程-2-AQS-ReentranLock线程锁</div></div><div class="info-2"><div class="info-item-1">目录 一、ReentrantLock 组成部分 Sync extends AbstractQueuedSynchronizer NonfairSync extends Sync  FairSync extends Sync   二、ReentrantLock 性质 1、独占锁 2、可重入锁&#x2F;不可重入锁 3、公平锁&#x2F;不公平锁   三、ReentrantLock Api说明 1、lock() 2、lockInterruptibly() 3、tryLock() 4、tryLock(long,TimeUnit) 5、unLock() 6、newCondition()   四、Condition实现通知机制 五、与Synchronized关键字对比  一、ReentrantLock组成部分 Sync extends AbstractQueuedSynchronizer NonfairSync extends SyncFairSync extends Sync二、ReentrantLock 性质1、独占锁 &#x2F;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="类加载机制（1）类加载过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">类加载机制（1）类加载过程</div></div><div class="info-2"><div class="info-item-1">目录 一、什么是类的加载（类初始化） 1、分清类初始化和对象初始化 2、类的初始化过程是在程序运行期间完成   二、类的生命周期：加验准析初使卸 1、加载 2、验证 3、准备【重点】 4、解析 5、初始化【重点】 （1）什么是初始化 （2）初始化的内容 （3）类初始化的六大节点：【主动引用】 （4）不会触发初始化的【被动引用】   6、使用 7、卸载 8、结束生命周期   三、接口的加载过程-比较特殊 四、总结 1、加载、连接、初始化 2、主动引用和被动引用 3、类初始化在jvm生命周期内只进行一次。   五、来看几道考试题 六、根据上边的最后一道题，总结整体执行顺序 七、对象初始化，继承问题，为什么构造方法中，不建议使用可重写的方法？Calling non-final function initView in constructor  一、什么是类的加载（类初始化）jvm通过加载、连接（验证、准备、解析）、初始化3大步将类加载进内存的过程叫做类的加载或类初始化。 关键点：1、分清类初始化和对象初始化的不同。-...</div></div></div></a><a class="pagination-related" href="/2024/12/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62/" title="类加载机制（2）类加载器源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">类加载机制（2）类加载器源码解析</div></div><div class="info-2"><div class="info-item-1">目录 一、类加载器 1、BootstrapClassLoader 启动类加载器 2、ExtensionClassLoader 扩展类加载器 3、ApplicationClassLoader 应用类加载器 4、CustomClassLoader 自定义类加载器 5、线程上下文类加载器   二、java虚拟机入口应用：sun.misc.Launcher 1、sun.misc.Launcher 主入口 2、内部类 ExtClassLoader extends URLClassLoader源码 3、内部类 AppClassLoader  extends URLClassLoader源码 4、真实父类URLClassLoader extends ClassLoader源码   三、双亲委派模型 1、工作流程 2、意义说明   四、ClassLoader源码分析 1、loadClass 实现双亲委派逻辑 2、findClass 通过path找到.class加载进byte[]二进制数组 3、defineClass(byte[] b)...</div></div></div></a><a class="pagination-related" href="/2024/12/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%883%EF%BC%89DexClassLoader%E5%BA%94%E7%94%A8%E7%AF%87/" title="类加载机制（3）DexClassLoader应用篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">类加载机制（3）DexClassLoader应用篇</div></div><div class="info-2"><div class="info-item-1">目录 一、Android中ClassLoader的说明 二、DexClassLoader使用 三、类加载机制的缓存 四、如何避过缓存 五、class二进制文件加载进内存哪个jvm分区？   一、Android中ClassLoader的说明   类加载器 说明    DexClassLoader 可以加载jar&#x2F;apk&#x2F;dex，可以从SD卡中加载未安装的apk；   PathClassLoader 只能加载系统中已经安装过的apk；   二、DexClassLoader使用参数说明    入参 说明    dexPath 表示dex文件的路径，这个路径可以是apk、jar、zip等文件的路径如果是多个文件的路径，可以通过File.pathSeparator来进行分割（在 Windows 上，此字段为 “;”，在 UNIX 上，此字段为 “:”）   optimizedDirectory 用于存储优化后的dex文件，这个目录不能是外部存储，因为Android系统不允许外部存储上的应用进行DEX优化。   librarySearchPath 用于查找...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-%E7%BA%BF%E7%A8%8B%E9%94%81%E5%88%86%E7%B1%BB/" title="线程-2-线程锁分类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">线程-2-线程锁分类</div></div><div class="info-2"><div class="info-item-1">一、按照其性质分类公平锁&#x2F;非公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁。 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。  对于Java...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-AQS-ReentranLock%E7%BA%BF%E7%A8%8B%E9%94%81/" title="线程-2-AQS-ReentranLock线程锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">线程-2-AQS-ReentranLock线程锁</div></div><div class="info-2"><div class="info-item-1">目录 一、ReentrantLock 组成部分 Sync extends AbstractQueuedSynchronizer NonfairSync extends Sync  FairSync extends Sync   二、ReentrantLock 性质 1、独占锁 2、可重入锁&#x2F;不可重入锁 3、公平锁&#x2F;不公平锁   三、ReentrantLock Api说明 1、lock() 2、lockInterruptibly() 3、tryLock() 4、tryLock(long,TimeUnit) 5、unLock() 6、newCondition()   四、Condition实现通知机制 五、与Synchronized关键字对比  一、ReentrantLock组成部分 Sync extends AbstractQueuedSynchronizer NonfairSync extends SyncFairSync extends Sync二、ReentrantLock 性质1、独占锁 &#x2F;...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8(safe)%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" title="线程-3-线程安全(safe)使用总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">线程-3-线程安全(safe)使用总结</div></div><div class="info-2"><div class="info-item-1">目录 一、保障线程安全的方法、用例     1、Volatile 保障可见性，抑制重排序；以及实现原理  2、原子操作类 Atomic（ABA问题）  3、Synchronized 同步代码块  4、Lock 线程锁   二、保障线程安全的数据结构 三、异步转同步的方法 1、Future&#x3D;executor.submit(callable)  2、countDownLatch  3、handler.runWithScissors   四、多线程异步加载场景解决 1、executor 线程池 2、rxjava2    五、生产者消费者模式 1、syncnazition形式 2、Lock形式 3、BlockingQueue阻塞队列形式   六、三个线程依次打印100个数 condition 实现    一、保障线程安全的方法、用例 1、Volatile 保障可见性 当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以考虑到不同的CPU...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">王征</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IRVING18"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:ivring18@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><span>一个通人性的博主，码字不易，用爱发电。希望大家多多支持。</span><img width="250px" src="/img/wechat_pay.png"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">一、线程状态-转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%90%86%E8%AE%BA%E4%B8%8A%E5%8F%AA%E6%9C%89%E4%B8%A4%E7%A7%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、创建线程的方式：理论上只有两种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-extends-Thread-%E5%AE%9E%E7%8E%B0run%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">(1) extends Thread 实现run方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BArunnable%EF%BC%8C%E4%BC%A0%E5%85%A5Thread-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">(2) 创建runnable，传入Thread()构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%AE%80%E7%89%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、简版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%8C%E6%95%B4%E7%89%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、完整版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84API"><span class="toc-number">1.2.</span> <span class="toc-text">二、线程的API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81Thread-yield"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1、Thread.yield()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81Thread-sleep"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2、Thread.sleep()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81Thread-interrupted"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">1.3、Thread.interrupted()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、普通成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81new-Thread-start"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.1、new Thread().start()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81new-Thread-run"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2、new Thread().run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81new-Thread-join-join-long-millis-join-long-millis-int-nanos"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.3、new Thread().join()&#x2F;join(long millis)&#x2F;join(long millis, int nanos)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E3%80%81new-Thread-setDaemon"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.4、new Thread().setDaemon()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E3%80%81new-Thread-setPriority"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.5、new Thread().setPriority()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E3%80%81new-Thread-stop"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">2.6、new Thread().stop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7%E3%80%81new-Thread-interrupt"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">2.7、new Thread().interrupt()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">三、线程锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81synchronized-%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、synchronized 隐式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Lock%E6%98%BE%E7%A4%BA%E9%94%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、Lock显示锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E9%94%81%E3%80%81%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、类锁、对象锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84API-%E5%BF%85%E9%A1%BB%E6%9C%89%E9%94%81%E6%89%8D%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">四、线程锁的API -&gt; 必须有锁才能调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Object%E9%94%81Api"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、Object锁Api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Lock%E9%94%81APi"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、Lock锁APi</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">五、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">资源的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">1、死锁的四大必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">1.5.3.</span> <span class="toc-text">2、死锁的预防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-number">1.5.4.</span> <span class="toc-text">3、死锁的避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E3%80%81%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.5.</span> <span class="toc-text">4、死锁预防、死锁避免的区别</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-%E7%BA%BF%E7%A8%8B%E9%94%81%E5%88%86%E7%B1%BB/" title="线程-2-线程锁分类">线程-2-线程锁分类</a><time datetime="2024-12-27T03:52:19.000Z" title="发表于 2024-12-27 11:52:19">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%883%EF%BC%89%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/" title="线程池（3）终止线程池原理">线程池（3）终止线程池原理</a><time datetime="2024-12-27T03:52:19.000Z" title="发表于 2024-12-27 11:52:19">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="线程池（2）execute()执行过程源码分析">线程池（2）execute()执行过程源码分析</a><time datetime="2024-12-27T03:45:07.000Z" title="发表于 2024-12-27 11:45:07">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8(safe)%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" title="线程-3-线程安全(safe)使用总结">线程-3-线程安全(safe)使用总结</a><time datetime="2024-12-27T03:45:00.000Z" title="发表于 2024-12-27 11:45:00">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-4-ThreadLocal/" title="线程-4-ThreadLocal">线程-4-ThreadLocal</a><time datetime="2024-12-27T03:44:58.000Z" title="发表于 2024-12-27 11:44:58">2024-12-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.png);"><div id="footer-wrap"><div class="copyright">&copy;2024 By 王征</div><div class="footer_custom_text"><a href=""><img class="icp-icon" src="/img/avatar.jpg"><span>一个通人性的博主</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>