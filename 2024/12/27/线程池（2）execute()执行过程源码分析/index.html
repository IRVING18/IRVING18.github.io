<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线程池（2）execute()执行过程源码分析 | 一个通人性的博主</title><meta name="author" content="王征"><meta name="copyright" content="王征"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[toc] 线程池ThreadPoolExecutor源码分析所需知识点： 1、ReentranLock 重入锁 以及 Condition的联合使用。 不可重入的互斥锁，AQS AbstractQueuedSynchronizer  AQS是怎么实现不可重入互斥锁的。 2、AtomicInteger 线程安全的int 3、volatile 线程安全关键字 4、BlockingQueue 阻塞线程队">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池（2）execute()执行过程源码分析">
<meta property="og:url" content="https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="一个通人性的博主">
<meta property="og:description" content="[toc] 线程池ThreadPoolExecutor源码分析所需知识点： 1、ReentranLock 重入锁 以及 Condition的联合使用。 不可重入的互斥锁，AQS AbstractQueuedSynchronizer  AQS是怎么实现不可重入互斥锁的。 2、AtomicInteger 线程安全的int 3、volatile 线程安全关键字 4、BlockingQueue 阻塞线程队">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://irving18.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-12-27T03:45:07.000Z">
<meta property="article:modified_time" content="2024-12-27T03:46:29.470Z">
<meta property="article:author" content="王征">
<meta property="article:tag" content="JAVA基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://irving18.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程池（2）execute()执行过程源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">一个通人性的博主</span></a><a class="nav-page-title" href="/"><span class="site-name">线程池（2）execute()执行过程源码分析</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">线程池（2）execute()执行过程源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-27T03:45:07.000Z" title="发表于 2024-12-27 11:45:07">2024-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-27T03:46:29.470Z" title="更新于 2024-12-27 11:46:29">2024-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<h1 id="线程池ThreadPoolExecutor源码分析"><a href="#线程池ThreadPoolExecutor源码分析" class="headerlink" title="线程池ThreadPoolExecutor源码分析"></a>线程池ThreadPoolExecutor源码分析</h1><h3 id="所需知识点："><a href="#所需知识点：" class="headerlink" title="所需知识点："></a>所需知识点：</h3><ul>
<li>1、ReentranLock 重入锁 以及 Condition的联合使用。</li>
<li>不可重入的互斥锁，AQS AbstractQueuedSynchronizer </li>
<li>AQS是怎么实现不可重入互斥锁的。</li>
<li>2、AtomicInteger 线程安全的int</li>
<li>3、volatile 线程安全关键字</li>
<li>4、BlockingQueue 阻塞线程队列</li>
</ul>
<h1 id="源码分析execute-执行过程"><a href="#源码分析execute-执行过程" class="headerlink" title="源码分析execute()执行过程"></a>源码分析execute()执行过程</h1><p>老规矩我们先上图：</p>
<p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_1.jpg" alt="image"></p>
<blockquote>
<p>1、如果线程池中的线程数量少于corePoolSize，就创建新的线程来执行新添加的任务</p>
<p>2、如果线程池中的线程数量大于等于corePoolSize，但队列workQueue未满，则将新添加的任务放到workQueue中</p>
<p>3、如果线程池中的线程数量大于等于corePoolSize，且队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务</p>
<p>4、如果线程池中的线程数量等于了maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略</p>
</blockquote>
<ul>
<li><a href="#jump1">一、ThreadPoolExecutor.execute()方法</a></li>
<li><a href="#jump2">二、ThreadPoolExecutor.addWorker()方法</a></li>
<li><a href="#jump3">三、Worker内部类</a></li>
<li><a href="#jump4">四、ThreadPoolExecutor.runWorker()</a></li>
<li><a href="#jump5">五、ThreadPoolExecutor.getTask()方法</a></li>
<li><a href="#jump6">六、ThreadPoolExecutor.processWorkerExit()方法</a></li>
<li><a href="#jump7">七、ThreadPoolExecutor.tryTerminate()方法</a></li>
<li><a href="#jump8">八、ThreadPoolExecutor.interruptIdleWorkers()方法</a></li>
</ul>
<h2 id="一、ThreadPoolExecutor-execute-方法"><a href="#一、ThreadPoolExecutor-execute-方法" class="headerlink" title="一、ThreadPoolExecutor.execute()方法"></a><span id="jump1">一、ThreadPoolExecutor.execute()方法</span></h2><p>流程图：<br><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_2.jpg" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     * 如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了） 或者 从我们进入这个方法后，pool被关闭了</span></span><br><span class="line"><span class="comment">     * 所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启 一个线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     * 如果无法将任务入队列（可能队列满了），需要新开区一个线程（自己：往maxPoolSize发展）</span></span><br><span class="line"><span class="comment">     * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取线程池当前状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、获取当前工作的Worker数量，如果小于核心线程池数量。就创建新的Worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//创建新worker对象，启动新线程，并且设置为true 核心线程。</span></span><br><span class="line">        <span class="comment">//如果添加创建成功直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//新增Worker失败，重新获取线程池状态值</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()）</span></span><br><span class="line"><span class="comment">         * 失败的原因可能是：</span></span><br><span class="line"><span class="comment">         * 1、线程池已经shutdown，shutdown的线程池不再接收新任务</span></span><br><span class="line"><span class="comment">         * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、走到这，说明核心线程池已满，或者线程池shutdown了。</span></span><br><span class="line"><span class="comment">     * 如果线程池在运行状态，并且workQueue队列插入成功。</span></span><br><span class="line"><span class="comment">     * BlockQueue #offer()特性，插入值失败返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//再次校验位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再次校验放入workerQueue中的任务是否能被执行</span></span><br><span class="line"><span class="comment">         * 1、如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务</span></span><br><span class="line"><span class="comment">         * 2、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），</span></span><br><span class="line"><span class="comment">         *  那么addWorker(null,false)确保还有线程执行任务（只要有一个就够了）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果线程池不再运行状态，并且workQueue成功删除了刚添加的任务，那么就调用拒绝handler方法。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null</span></span><br><span class="line">        <span class="comment">//为什么只检查运行的worker数量是不是0呢？？ 为什么不和corePoolSize比较呢？？</span></span><br><span class="line">        <span class="comment">//只保证有一个worker线程可以从queue中获取任务执行就行了？？</span></span><br><span class="line">        <span class="comment">//因为只要还有活动的worker线程，就可以消费workerQueue中的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);<span class="comment">//第一个参数为null，说明只为新建一个worker线程，没有指定firstTask</span></span><br><span class="line">        <span class="comment">//第二个参数为true代表占用corePoolSize，false占用maxPoolSize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、如果添加workQueue队列失败，那么就尝试添加非核心线程。</span></span><br><span class="line"><span class="comment">     * 直到线程扩容超过maximumPoolSize，addWorker失败就会调用拒绝handler方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结分析：<br>execute(Runnable command)</p>
<p>参数：</p>
<pre><code>command    提交执行的任务，不能为空
</code></pre>
<p>执行流程：</p>
<p>1、如果线程池当前线程数量少于corePoolSize，则addWorker(command, true)创建新worker线程，如创建成功返回，如没创建成功，则执行后续步骤；</p>
<pre><code>addWorker(command, true)失败的原因可能是：
A、线程池已经shutdown，shutdown的线程池不再接收新任务
B、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize
</code></pre>
<p>2、如果线程池还在running状态，将task加入workQueue阻塞队列中，如果加入成功，进行double-check，如果加入失败（可能是队列已满），则执行后续步骤；</p>
<pre><code>double-check主要目的是判断刚加入workQueue阻塞队列的task是否能被执行
A、如果线程池已经不是running状态了，应该拒绝添加新任务，从workQueue中删除任务
B、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）
</code></pre>
<p>3、如果线程池不是running状态 或者 无法入队列，尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</p>
<h2 id="二、ThreadPoolExecutor-addWorker-方法"><a href="#二、ThreadPoolExecutor-addWorker-方法" class="headerlink" title="二、ThreadPoolExecutor.addWorker()方法"></a><span id="jump2">二、ThreadPoolExecutor.addWorker()方法</span></h2><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_3.jpg" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> *  检查根据当前线程池的状态和给定的边界(core or maximum)是否可以创建一个新的worker</span></span><br><span class="line"><span class="comment"> *  * 如果是这样的话，worker的数量做相应的调整，如果可能的话，创建一个新的worker并启动，参数中的firstTask作为worker的第一个任务</span></span><br><span class="line"><span class="comment"> *  * 如果方法返回false，可能因为pool已经关闭或者调用过了shutdown</span></span><br><span class="line"><span class="comment"> *  * 如果线程工厂创建线程失败，也会失败，返回false</span></span><br><span class="line"><span class="comment"> *  * 如果线程创建失败，要么是因为线程工厂返回null，要么是发生了OutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">//外层循环，负责判断线程池状态</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池的state越小越是运行状态，running=-1，shutdown=0, stop=1, tidying=2，terminated=3</span></span><br><span class="line"><span class="comment">         * 1、如果线程池state已经至少是shutdown状态了</span></span><br><span class="line"><span class="comment">         * 2、并且以下3个条件任意一个是false</span></span><br><span class="line"><span class="comment">         *   rs == SHUTDOWN         （隐含：rs&gt;=SHUTDOWN）false情况： 线程池状态已经超过shutdown，可能是stop、tidying、terminated其中一个，即线程池已经终止</span></span><br><span class="line"><span class="comment">         *   firstTask == null      （隐含：rs==SHUTDOWN）false情况： firstTask不为空，rs==SHUTDOWN 且 firstTask不为空，return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝</span></span><br><span class="line"><span class="comment">         *   ! workQueue.isEmpty()  （隐含：rs==SHUTDOWN，firstTask==null）false情况： workQueue为空，当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，如果workQueue已经为空，那么就没有添加新worker线程的必要了</span></span><br><span class="line"><span class="comment">         * return false，即无法addWorker()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内层循环，负责worker数量+1</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前worker数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">//如果worker数量&gt;线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值）</span></span><br><span class="line">            <span class="comment">//或者( worker数量&gt;corePoolSize 或  worker数量&gt;maximumPoolSize )，即已经超过了给定的边界</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用unsafe CAS操作，使得worker数量+1，成功则跳出外层retry循环</span></span><br><span class="line">            <span class="comment">//CAS 即Compare and Swap 调用AtomicInteger的同步+1方法，这个方法可能会失败，返回true成功，false失败</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重新验证线程池运行状态</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//如果当前状态和外层循环开始时不一样了，那么回到外层循环重新开始。</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * worker数量+1成功的后续操作</span></span><br><span class="line"><span class="comment">     * 添加到workers Set集合，并启动worker线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、设置worker这个AQS锁的同步状态state=-1</span></span><br><span class="line">        <span class="comment">//2、将firstTask设置给worker的成员变量firstTask</span></span><br><span class="line">        <span class="comment">//3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//--------------------------------------------这部分代码是上锁的</span></span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 当获取到锁后，再次检查线程池运行状态，</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果线程池在运行running&lt;shutdown 或者 线程池已经shutdown，且firstTask==null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行）</span></span><br><span class="line">                <span class="comment">//worker数量-1的操作在addWorkerFailed()</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable 线程已经启动，抛非法线程状态异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//workers是一个HashSet&lt;Worker&gt;,将worker存入</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//标识worker添加成功</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加成功，启动线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果启动失败，回滚操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果worker不为空，就从workQueue移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//里边就是调用AtomicInteger#compareAndSet(expect, expect - 1) 减了1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>addWorker(Runnable firstTask, boolean core)</p>
<p>参数：</p>
<pre><code>firstTask：    worker线程的初始任务，可以为空
core：           true：将corePoolSize作为上限，false：将maximumPoolSize作为上限
</code></pre>
<p>addWorker方法有4种传参的方式：</p>
<pre><code>1、addWorker(command, true)

2、addWorker(command, false)

3、addWorker(null, false)

4、addWorker(null, true)
</code></pre>
<p>在execute方法中就使用了前3种，结合这个核心方法进行以下分析</p>
<pre><code>第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false
第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false
第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务
第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行
</code></pre>
<p>执行流程：</p>
<pre><code>1、判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false：
    A、线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程
    B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务
    C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了
    添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义
2、线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步
3、在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，
如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑
</code></pre>
<h2 id="三、Worker内部类"><a href="#三、Worker内部类" class="headerlink" title="三、Worker内部类"></a><span id="jump3">三、Worker内部类</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class Worker mainly maintains interrupt control state for</span></span><br><span class="line"><span class="comment"> * threads running tasks, along with other minor bookkeeping.</span></span><br><span class="line"><span class="comment"> * This class opportunistically extends AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment"> * to simplify acquiring and releasing a lock surrounding each</span></span><br><span class="line"><span class="comment"> * task execution.This protects against interrupts that are</span></span><br><span class="line"><span class="comment"> * intended to wake up a worker thread waiting for a task from</span></span><br><span class="line"><span class="comment"> * instead interrupting a task being run.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We implement a simple non-reentrant mutual exclusion lock rather than use</span></span><br><span class="line"><span class="comment"> * ReentrantLock because we do not want worker tasks to be able to</span></span><br><span class="line"><span class="comment"> * reacquire the lock when they invoke pool control methods like</span></span><br><span class="line"><span class="comment"> * setCorePoolSize.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Additionally, to suppress interrupts until</span></span><br><span class="line"><span class="comment"> * the thread actually starts running tasks, we initialize lock</span></span><br><span class="line"><span class="comment"> * state to a negative value, and clear it upon start (in</span></span><br><span class="line"><span class="comment"> * runWorker).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Worker类大体上管理着运行线程的中断状态 和 一些指标</span></span><br><span class="line"><span class="comment"> * Worker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁</span></span><br><span class="line"><span class="comment"> * 这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程</span></span><br><span class="line"><span class="comment"> *   解释：</span></span><br><span class="line"><span class="comment"> *    为什么不直接在execute(runnable command)直接执行command，而要包一层Worker呢？</span></span><br><span class="line"><span class="comment"> *        1、主要目的是为了控制线程中断，使用不可重入的互斥锁AQS，来限制同一线程中其他操作导致线程中断。</span></span><br><span class="line"><span class="comment"> *        2、正常shutdown()方法，调用的是interruptIdleWorkers()，这个方法是需要w.tryLock()的，</span></span><br><span class="line"><span class="comment"> *        也就是用不可重入锁AQS协助拦截正在运行的线程调用t.intercept()中断。所以shutdown()方法</span></span><br><span class="line"><span class="comment"> *        不会中断正在执行任务的worker线程。</span></span><br><span class="line"><span class="comment"> *        3、但如果shutdownNow()方法，调用的是interruptWorkers()，这个方法并不加锁，而是直接遍历</span></span><br><span class="line"><span class="comment"> *        所有worker，并t.intercept()。所以shutdownNow()相当于会中断正在执行的Worker线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * worker实现了一个简单的不可重入的互斥锁，而不是用ReentrantLock可重入锁</span></span><br><span class="line"><span class="comment"> * 因为我们不想让在调用比如setCorePoolSize()这种线程池控制方法时可以再次获取锁(重入)</span></span><br><span class="line"><span class="comment"> *   解释：</span></span><br><span class="line"><span class="comment"> *     1、setCorePoolSize()时会调用interruptIdleWorkers()，通过这个方法里w.tryLock()来拦截</span></span><br><span class="line"><span class="comment"> *     利用不可重入锁的特性，保证同一线程中执行时也会阻塞，来保证worker不被中断。</span></span><br><span class="line"><span class="comment"> *     2、类似的方法还有（只要调用interruptIdleWorkers()的全是）：</span></span><br><span class="line"><span class="comment"> *     shutdown()</span></span><br><span class="line"><span class="comment"> *     setMaximumPoolSize()</span></span><br><span class="line"><span class="comment"> *     setKeepAliveTime()</span></span><br><span class="line"><span class="comment"> *     allowCoreThreadTimeOut()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 另外，为了保证只有worker中的线程已经在运行状态才能被中断。我们初始化state = -1，并在runWorker()</span></span><br><span class="line"><span class="comment"> * 启动线程时，将state设置 = 0。</span></span><br><span class="line"><span class="comment"> *    解释：</span></span><br><span class="line"><span class="comment"> *      1、创建Worker过程并没有真正的t.start()启动线程。在runWorker()中才调用启动线程。</span></span><br><span class="line"><span class="comment"> *      2、所以在t.start()之前并没有必要去中断线程。只有state &gt;= 0的时候，才表示有线程可中断。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个类永远都不会被序列化，我们提供序列号id只是解决javac 的警告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter 记录已经完成的任务数*/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">//初始化state为-1，在runWorker()调用t.start()时再设置为0</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="comment">//任务可能为null，为空时runWorker()时就会自旋，getTask()，不断获取workQueue中的任务。</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//通过线程工厂创建线程</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 获取锁状态，0表示未锁，1表示已锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁方法。AQS获取锁的时候会调用这个，本身就是让子类实现的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里判断逻辑是通过(CAS)unsafe.compareAndSwapInt的原子性，来比较并设置值。</span></span><br><span class="line"><span class="comment">     * 最终是比较当前state == 0 ？那么就设置为 1 并返回true。</span></span><br><span class="line"><span class="comment">     *   true: 将当前线程绑定上。return true表示获取锁成功</span></span><br><span class="line"><span class="comment">     *   false: 获取锁失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁，将state置为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock方法也会调用tryAcquire()方法，但是获取失败会中断线程。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束线程t。如果线程已经start()，并且线程t不为空，也不是中断状态，那么就中断。</span></span><br><span class="line"><span class="comment">     * 这个方法再shutdownNow()中使用了，不获取锁直接中断，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Worker存在的意义："><a href="#Worker存在的意义：" class="headerlink" title="Worker存在的意义："></a>Worker存在的意义：</h4><pre><code>- 1、控制中断，保证task能够完整执行。防止在shutdown()等情况下意外中断。
- 2、控制自旋获取getTask()。
- 3、控制自身退出时机
</code></pre>
<h4 id="Worker如何实现不可重入锁：state-1-0-1"><a href="#Worker如何实现不可重入锁：state-1-0-1" class="headerlink" title="Worker如何实现不可重入锁：state (-1,0,1)"></a>Worker如何实现不可重入锁：state (-1,0,1)</h4><pre><code>控制中断，主要意义就是尽量保证worker中正在执行的task能成功执行完。
不要在执行过程中被其他方法intercept()了。
- 1、继承AQS(AbstractQueuedSynchronizer)实现不可重入锁
- 2、在new Worker()时,线程还没有start()时,state设置-1。此时线程如果调用intercept()没有意义。
在runWoker()=&gt;t.start()时再设置state=0
- 3、在tryLock()-&gt;tryAcquire()，使用CAS先比较再重置的方式设置state 0=&gt;1，就保证了不可重入锁。
因为只有state=0时才能重新设置，其他-1，1的情况都不能设置成功。
</code></pre>
<h4 id="Worker如何控制中断"><a href="#Worker如何控制中断" class="headerlink" title="Worker如何控制中断"></a>Worker如何控制中断</h4><pre><code>- 1、初始化AQS state = -1，此时不允许调用interrupt()。只有runWorker()将state设置为0才允许调用中断。
- 2、shutdown()，setMaximumPoolSize()等安全退出或改变线程池的方法，都会调用interruptIdleWorkers();中断空闲worker的方法。
这个方法中会遍历所有worker，然后尝试获取锁tryLock()，如果tryLock()获取成功，则说明该worker属于空闲状态，
因为worker自旋时如果获取到task的话就会lock()。只有在getTask()阻塞状态时才会释放锁。故如果w.tryLock()能成功获取锁，
则说明worker空闲。这一点就是利用不可重入锁的特点来实现的。
- 3、shutdownNow()，调用的是interruptWorkers()，这个方法是直接遍历worker，直接调用interrupt()，并不会去获取锁。
但是判断state是不是&gt;-1，因为state=-1时，线程都没有start()呢，没必要中断。
</code></pre>
<h2 id="四、ThreadPoolExecutor-runWorker"><a href="#四、ThreadPoolExecutor-runWorker" class="headerlink" title="四、ThreadPoolExecutor.runWorker()"></a><span id="jump4">四、ThreadPoolExecutor.runWorker()</span></h2><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_4.jpg" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> * 重复的从队列中获取任务并执行，同时应对一些问题：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> * 我们可能使用一个初始化任务开始，即firstTask为null</span></span><br><span class="line"><span class="comment"> * 然后只要线程池在运行，我们就从getTask()获取任务</span></span><br><span class="line"><span class="comment"> * 如果getTask()返回null，则worker由于改变了线程池状态或参数配置而退出</span></span><br><span class="line"><span class="comment"> * 其它退出因为外部代码抛异常了，这会使得completedAbruptly为true，这会导致在processWorkerExit()方法中替换当前线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and</span></span><br><span class="line"><span class="comment"> * clearInterruptsForTaskRun called to ensure that unless pool is</span></span><br><span class="line"><span class="comment"> * stopping, this thread does not have its interrupt set.</span></span><br><span class="line"><span class="comment"> * 在任何任务执行之前，都需要对worker加锁去防止在任务运行时，其它的线程池中断操作</span></span><br><span class="line"><span class="comment"> * clearInterruptsForTaskRun保证除非线程池正在stoping，线程不会被设置中断标示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> * 每个任务执行前会调用beforeExecute()，其中可能抛出一个异常，这种情况下会导致线程die（跳出循环，且completedAbruptly==true），没有执行任务</span></span><br><span class="line"><span class="comment"> * 因为beforeExecute()的异常没有cache住，会上抛，跳出循环</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to</span></span><br><span class="line"><span class="comment"> * afterExecute. We separately handle RuntimeException, Error</span></span><br><span class="line"><span class="comment"> * (both of which the specs guarantee that we trap) and arbitrary</span></span><br><span class="line"><span class="comment"> * Throwables.  Because we cannot rethrow Throwables within</span></span><br><span class="line"><span class="comment"> * Runnable.run, we wrap them within Errors on the way out (to the</span></span><br><span class="line"><span class="comment"> * thread&#x27;s UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> * 假定beforeExecute()正常完成，我们执行任务</span></span><br><span class="line"><span class="comment"> * 汇总任何抛出的异常并发送给afterExecute(task, thrown)</span></span><br><span class="line"><span class="comment"> * 因为我们不能在Runnable.run()方法中重新上抛Throwables，我们将Throwables包装到Errors上抛（会到线程的UncaughtExceptionHandler去处理）</span></span><br><span class="line"><span class="comment"> * 任何上抛的异常都会导致线程die</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> * 任务执行结束后，调用afterExecute()，也可能抛异常，也会导致线程die</span></span><br><span class="line"><span class="comment"> * 根据JLS Sec 14.20，这个异常（finally中的异常）会生效</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line"><span class="comment">//      runWorker()这个方法执行节点是Worker.run()，而run()方法执行节点是addWorker()里的worker.t.start()。</span></span><br><span class="line"><span class="comment">//      所以执行到这个方法的时候，说明线程已经start()了。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目的是调用worker的tryRelease()方法，将state 置为 0。</span></span><br><span class="line">    <span class="comment">// 意思是当前线程已经运行了，如果有人需要intercept()中断。就可以调用了。</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程是否为正常退出的。不抛意想不到的异常就会将这个值置为false。</span></span><br><span class="line">    <span class="comment">//这个标识会传到processWorkerExit()中，在里边判断如果不是正常退出会启动一个新worker来继续处理出现问题的task。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断firstTask不为空，或者从workQueue阻塞队列中拿到了任务。就就开始执行task。</span></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//开始任务之前先加锁，而且是不可重入的互斥锁。不可重入的目的在Worker中已经说过了。</span></span><br><span class="line">            <span class="comment">//上锁，不是为了防止并发执行任务，为了在shutdown()时不终止正在运行的worker</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * clearInterruptsForTaskRun操作</span></span><br><span class="line"><span class="comment">             * 确保只有在线程stoping时，才会被设置中断标示，否则清除中断标示</span></span><br><span class="line"><span class="comment">             * 1、如果线程池状态&gt;=stop，且当前线程没有设置中断状态，wt.interrupt()</span></span><br><span class="line"><span class="comment">             * 2、如果一开始判断线程池状态&lt;stop，但Thread.interrupted()为true，即线程已经被中断，又清除了中断标示，再次判断线程池状态是否&gt;=stop</span></span><br><span class="line"><span class="comment">             *   是，再次设置中断标示，wt.interrupt()</span></span><br><span class="line"><span class="comment">             *   否，不做操作，清除中断标示后进行后续步骤</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// RUNNING    = -1</span></span><br><span class="line">            <span class="comment">// SHUTDOWN   =  0</span></span><br><span class="line">            <span class="comment">// STOP       =  1</span></span><br><span class="line">            <span class="comment">// TIDYING    =  2</span></span><br><span class="line">            <span class="comment">// TERMINATED =  3</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                    (runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</span><br><span class="line">                     &amp;&amp; !wt.isInterrupted()</span><br><span class="line">            )</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//任务执行前（子类实现，可自定义操作）</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行后（子类实现，可自定义操作）</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;<span class="comment">//完成任务数+1</span></span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//处理worker的退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<pre><code>1、Worker线程启动后，通过Worker类的run()方法调用runWorker(this)
2、执行任务之前，首先worker.unlock()，将AQS的state置为0，允许中断当前worker线程
3、开始执行firstTask，调用task.run()，在执行任务前会上锁wroker.lock()，在执行完任务后会解锁，为了防止在任务运行时被线程池一些中断操作中断
4、在任务执行前后，可以根据业务场景自定义beforeExecute() 和 afterExecute()方法
5、无论在beforeExecute()、task.run()、afterExecute()发生异常上抛，都会导致worker线程终止，进入processWorkerExit()处理worker退出的流程
6、如正常执行完当前task后，会通过getTask()从阻塞队列中获取新任务，当队列中没有任务，且获取任务超时，那么当前worker也会进入退出流程
</code></pre>
<h2 id="五、ThreadPoolExecutor-getTask-方法"><a href="#五、ThreadPoolExecutor-getTask-方法" class="headerlink" title="五、ThreadPoolExecutor.getTask()方法"></a><span id="jump5">五、ThreadPoolExecutor.getTask()方法</span></h2><p><img src="https://raw.githubusercontent.com/IRVING18/pic/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_5.jpg" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment">* current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment">* must exit because of any of:</span></span><br><span class="line"><span class="comment">* 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment">*    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment">* 2. The pool is stopped.</span></span><br><span class="line"><span class="comment">* 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment">* 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment">*    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment">*    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment">*    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment">*    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 执行阻塞队列的：阻塞获取方法：take() 或者 超时等待方法：poll(timeout)方法，取决于当前的配置。</span></span><br><span class="line"><span class="comment">* 如果这个worker返回null，必须满足如下条件：</span></span><br><span class="line"><span class="comment">* 1、超过最大线程数量（因为调用了setMaximumPoolSize()）</span></span><br><span class="line"><span class="comment">* 2、线程池stop了</span></span><br><span class="line"><span class="comment">* 3、线程池shutdown了，并且任务队列queue为空</span></span><br><span class="line"><span class="comment">* 4、这个worker不是核心线程、或者设置了允许核心线程退出。并且超过了keepAliveTime的等待时间，</span></span><br><span class="line"><span class="comment">* 仍然没有获取到task，那么return null</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  如果返回null，那么worker就是要退出了，所以把工作计数 - 1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment">*         workerCount is decremented</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取线程池状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池状态已经在SHUTDOWN之后了 &amp;&amp; (线程池状态在STOP之后了  ||  工作队列为空了)</span></span><br><span class="line">    <span class="comment">//那么返回null，退出线程。并且调用decrementWorkerCount，（CAS)方式核减调当前线程数。</span></span><br><span class="line"><span class="comment">//            RUNNING    = -1 &lt;&lt; COUNT_BITS;</span></span><br><span class="line"><span class="comment">//            SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span></span><br><span class="line"><span class="comment">//            STOP       =  1 &lt;&lt; COUNT_BITS;</span></span><br><span class="line"><span class="comment">//            TIDYING    =  2 &lt;&lt; COUNT_BITS;</span></span><br><span class="line"><span class="comment">//            TERMINATED =  3 &lt;&lt; COUNT_BITS;</span></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line"><span class="comment">//                （CAS)方式核减调当前线程数。</span></span><br><span class="line">        <span class="comment">//方法里最终是循环调用 ctl.compareAndSet(expect, expect - 1);，直到成功</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker是否允许退出？</span></span><br><span class="line">    <span class="comment">// 设置了允许核心线程退出 || 当前线程数 &gt; 核心线程数</span></span><br><span class="line">    <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(当前线程数 &gt; maximumPollSize || (允许线程退出 &amp;&amp; timedOut超时事件过后仍然没有任务))</span></span><br><span class="line">    <span class="comment">// &amp;&amp; (线程数 &gt; 1 || 任务队列queue为空)</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">            (wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">//调用CAS方式，把工作线程数-1，如果-1成功就直接返回null。如果失败就再循环一圈。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//允许线程退出 ？ 调用poll() : 调用take()</span></span><br><span class="line">        <span class="comment">//poll(keepAliveTime)方法，是等待超过keepAliveTime之后会返回null。</span></span><br><span class="line">        <span class="comment">//take()方法，是一直处于阻塞状态，直到队列中有新数据插入时，拿到数据。</span></span><br><span class="line">        <span class="comment">//workQueue的源码分析过，</span></span><br><span class="line">        <span class="comment">// 1、其实就是take()获取时通过线程锁的Condition属性控制线程睡眠挂起await()</span></span><br><span class="line">        <span class="comment">//      Condition notEmpty = lock.newCondition()</span></span><br><span class="line">        <span class="comment">//      notEmpty.await()睡眠等待。</span></span><br><span class="line">        <span class="comment">// 2、在插入时，notEmpty.signal();进行线程唤醒而已。</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        <span class="comment">//执行到这，意味着当前线程具备退出条件了。下次循环后再结合其他条件确定是否返回null</span></span><br><span class="line">        timedOut = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">        <span class="comment">//如果抛异常，那么退出标识就先置为false，继续自旋</span></span><br><span class="line">        timedOut = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是利用workQueue阻塞队列的特性：</p>
<pre><code>A、workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null
B、workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待await()；当队列中有任务加入时，线程被唤醒signal()，take方法返回任务
</code></pre>
<h2 id="六、ThreadPoolExecutor-processWorkerExit-方法"><a href="#六、ThreadPoolExecutor-processWorkerExit-方法" class="headerlink" title="六、ThreadPoolExecutor.processWorkerExit()方法"></a><span id="jump6">六、ThreadPoolExecutor.processWorkerExit()方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment"> * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment"> * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment"> * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment"> * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment"> * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment"> * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment"> * there are no workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为被干掉的worker调用清理方法和记录。这个方法只会被worker线程调用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(ThreadPoolExecutor.Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、worker数量-1</span></span><br><span class="line"><span class="comment">     * 如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1</span></span><br><span class="line"><span class="comment">     * 如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//在runWorker中抛异常了才为true，那么就调用CAS方式将工作线程-1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、从Workers Set中移除worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//线程加锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//已完成任务总数 += worker的完成数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//将该worker从HashSet中移除</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池</span></span><br><span class="line"><span class="comment">     * 主要是判断线程池是否满足终止的状态</span></span><br><span class="line"><span class="comment">     * 如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程</span></span><br><span class="line"><span class="comment">     * 没有线程了，更新状态为tidying-&gt;terminated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、是否需要增加worker线程</span></span><br><span class="line"><span class="comment">     *    1.线程池状态是running 或 shutdown</span></span><br><span class="line"><span class="comment">     *    2.如果当前线程是突然终止的，addWorker()</span></span><br><span class="line"><span class="comment">     *    3.如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span></span><br><span class="line"><span class="comment">     * 故如果调用线程池shutdown()，直到workQueue为空前，</span></span><br><span class="line"><span class="comment">     * 线程池都会维持corePoolSize个或者1个线程，然后再逐渐销毁这corePoolSize个或者1个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">//如果状态是running、shutdown，即tryTerminate()没有成功终止线程池，尝试再添加一个worker</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//不是突然完成的，即没有task任务可以获取而完成的，计算min，并根据当前worker数量判断是否需要addWorker()</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//最小值min = 如果允许核心线程退出，那么最小值就是0。否则就是核心线程数。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">//如果最小值为0 &amp;&amp; 工作队列不为空，那么意味着任务没有消化完，至少还需要一个worker去消化。</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果当前的工作worker数量 &gt;= 最小值，就不需要加worker了。否则就会执行下边的addWorker(null,false)方法，添加worker</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个没有firstTask的worker</span></span><br><span class="line">        <span class="comment">//只要worker是completedAbruptly突然终止的，或者线程数量小于要维护的数量，就新添一个worker线程。</span></span><br><span class="line">        <span class="comment">//因为抛出异常的情况可能是workQueue的task并没有完成执行完。启动一个空task的worker去消化workQueue队列</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、ThreadPoolExecutor-tryTerminate-方法"><a href="#七、ThreadPoolExecutor-tryTerminate-方法" class="headerlink" title="七、ThreadPoolExecutor.tryTerminate()方法"></a><span id="jump7">七、ThreadPoolExecutor.tryTerminate()方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span></span><br><span class="line"><span class="comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span></span><br><span class="line"><span class="comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span></span><br><span class="line"><span class="comment"> * idle worker to ensure that shutdown signals propagate. This</span></span><br><span class="line"><span class="comment"> * method must be called following any action that might make</span></span><br><span class="line"><span class="comment"> * termination possible -- reducing worker count or removing tasks</span></span><br><span class="line"><span class="comment"> * from the queue during shutdown. The method is non-private to</span></span><br><span class="line"><span class="comment"> * allow access from ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在以下情况将线程池变为TERMINATED终止状态</span></span><br><span class="line"><span class="comment"> * shutdown 且 正在运行的worker 和 workQueue队列 都empty</span></span><br><span class="line"><span class="comment"> * stop 且  没有正在运行的worker</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个方法必须在任何可能导致线程池终止的情况下被调用，如：</span></span><br><span class="line"><span class="comment"> * 减少worker数量</span></span><br><span class="line"><span class="comment"> * shutdown时从queue中移除任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个方法不是私有的，所以允许子类ScheduledThreadPoolExecutor调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这个for循环主要是和进入关闭线程池操作的CAS判断结合使用的</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池是否需要终止</span></span><br><span class="line"><span class="comment">         * 如果以下3中情况任一为true，return，不进行终止</span></span><br><span class="line"><span class="comment">         * 1、还在运行状态</span></span><br><span class="line"><span class="comment">         * 2、状态是TIDYING、或 TERMINATED，已经终止过了</span></span><br><span class="line"><span class="comment">         * 3、SHUTDOWN 且 workQueue不为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 只有shutdown状态 且 workQueue为空，或者 stop状态能执行到这一步</span></span><br><span class="line"><span class="comment">         * 如果此时线程池还有线程（正在运行任务，正在等待任务）</span></span><br><span class="line"><span class="comment">         * 中断唤醒一个正在等任务的空闲worker</span></span><br><span class="line"><span class="comment">         * 唤醒后再次判断线程池状态，会return null，进入processWorkerExit()流程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate 资格终止</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE); <span class="comment">//中断workers集合中的空闲任务，参数为true，只中断一个</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果状态是SHUTDOWN，workQueue也为空了，正在运行的worker也没有了，开始terminated</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//CAS：将线程池的ctl变成TIDYING（所有的任务被终止，workCount为0，为此状态时将会调用terminated()方法），期间ctl有变化就会失败，会再次for循环</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated(); <span class="comment">//需子类实现</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">//将线程池的ctl变成TERMINATED</span></span><br><span class="line">                    termination.signalAll(); <span class="comment">//唤醒调用了 等待线程池终止的线程 awaitTermination() </span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        <span class="comment">// 如果上面的CAS判断false，再次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、ThreadPoolExecutor-interruptIdleWorkers-方法"><a href="#八、ThreadPoolExecutor-interruptIdleWorkers-方法" class="headerlink" title="八、ThreadPoolExecutor.interruptIdleWorkers()方法"></a><span id="jump8">八、ThreadPoolExecutor.interruptIdleWorkers()方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts threads that might be waiting for tasks (as</span></span><br><span class="line"><span class="comment"> * indicated by not being locked) so they can check for</span></span><br><span class="line"><span class="comment"> * termination or configuration changes. Ignores</span></span><br><span class="line"><span class="comment"> * SecurityExceptions (in which case some threads may remain</span></span><br><span class="line"><span class="comment"> * uninterrupted).</span></span><br><span class="line"><span class="comment"> * 中断在等待任务的线程(没有上锁的)，中断唤醒后，可以判断线程池状态是否变化来决定是否继续</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span></span><br><span class="line"><span class="comment"> * called only from tryTerminate when termination is otherwise</span></span><br><span class="line"><span class="comment"> * enabled but there are still other workers.  In this case, at</span></span><br><span class="line"><span class="comment"> * most one waiting worker is interrupted to propagate shutdown</span></span><br><span class="line"><span class="comment"> * signals in case(以免) all threads are currently waiting.</span></span><br><span class="line"><span class="comment"> * Interrupting any arbitrary thread ensures that newly arriving</span></span><br><span class="line"><span class="comment"> * workers since shutdown began will also eventually exit.</span></span><br><span class="line"><span class="comment"> * To guarantee eventual termination, it suffices to always</span></span><br><span class="line"><span class="comment"> * interrupt only one idle worker, but shutdown() interrupts all</span></span><br><span class="line"><span class="comment"> * idle workers so that redundant workers exit promptly, not</span></span><br><span class="line"><span class="comment"> * waiting for a straggler task to finish.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * onlyOne如果为true，最多interrupt一个worker</span></span><br><span class="line"><span class="comment"> * 只有当终止流程已经开始，但线程池还有worker线程时,tryTerminate()方法会做调用onlyOne为true的调用</span></span><br><span class="line"><span class="comment"> * （终止流程已经开始指的是：shutdown状态 且 workQueue为空，或者 stop状态）</span></span><br><span class="line"><span class="comment"> * 在这种情况下，最多有一个worker被中断，为了传播shutdown信号，以免所有的线程都在等待</span></span><br><span class="line"><span class="comment"> * 为保证线程池最终能终止，这个操作总是中断一个空闲worker</span></span><br><span class="line"><span class="comment"> * 而shutdown()中断所有空闲worker，来保证空闲线程及时退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123; </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">//w.tryLock()，只有执行完task，正在getTask()阻塞状态的worker才能获取到lock。因为runWorker()时获取到task,会先lock()</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://irving18.github.io">王征</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://irving18.github.io/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://irving18.github.io" target="_blank">一个通人性的博主</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%883%EF%BC%89%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/" title="线程池（3）终止线程池原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">线程池（3）终止线程池原理</div></div><div class="info-2"><div class="info-item-1">[toc] 终止线程池一、终止线程池方法1、 shutdown() 安全的终止线程池- checkShutdownAccess()  核查当前线程是否有权限intercept() - advanceRunState(SHUTDOWN) 设置CAS方式设置线程池shutdown状态 - interruptIdleWorkers()中断空闲线程 - onShutdown()钩子函数 - tryTerminate()尝试中断线程池  2、 shutdownNow() 强制终止线程池- checkShutdownAccess()  核查当前线程是否有权限intercept() - advanceRunState(STOP) 设置CAS方式设置线程池Stop状态 - interruptWorkers() 中断所有线程(不会尝试获取锁w.tryLock，直接intercept) - tasks = drainQueue(); //将workQueue中的元素放入一个List并返回 - tryTerminate();尝试中断线程池  3、 awaitTermination(timeout)...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8(safe)%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" title="线程-3-线程安全(safe)使用总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">线程-3-线程安全(safe)使用总结</div></div><div class="info-2"><div class="info-item-1">目录 一、保障线程安全的方法、用例     1、Volatile 保障可见性，抑制重排序；以及实现原理  2、原子操作类 Atomic（ABA问题）  3、Synchronized 同步代码块  4、Lock 线程锁   二、保障线程安全的数据结构 三、异步转同步的方法 1、Future&#x3D;executor.submit(callable)  2、countDownLatch  3、handler.runWithScissors   四、多线程异步加载场景解决 1、executor 线程池 2、rxjava2    五、生产者消费者模式 1、syncnazition形式 2、Lock形式 3、BlockingQueue阻塞队列形式   六、三个线程依次打印100个数 condition 实现    一、保障线程安全的方法、用例 1、Volatile 保障可见性 当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以考虑到不同的CPU...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="类加载机制（1）类加载过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">类加载机制（1）类加载过程</div></div><div class="info-2"><div class="info-item-1">目录 一、什么是类的加载（类初始化） 1、分清类初始化和对象初始化 2、类的初始化过程是在程序运行期间完成   二、类的生命周期：加验准析初使卸 1、加载 2、验证 3、准备【重点】 4、解析 5、初始化【重点】 （1）什么是初始化 （2）初始化的内容 （3）类初始化的六大节点：【主动引用】 （4）不会触发初始化的【被动引用】   6、使用 7、卸载 8、结束生命周期   三、接口的加载过程-比较特殊 四、总结 1、加载、连接、初始化 2、主动引用和被动引用 3、类初始化在jvm生命周期内只进行一次。   五、来看几道考试题 六、根据上边的最后一道题，总结整体执行顺序 七、对象初始化，继承问题，为什么构造方法中，不建议使用可重写的方法？Calling non-final function initView in constructor  一、什么是类的加载（类初始化）jvm通过加载、连接（验证、准备、解析）、初始化3大步将类加载进内存的过程叫做类的加载或类初始化。 关键点：1、分清类初始化和对象初始化的不同。-...</div></div></div></a><a class="pagination-related" href="/2024/12/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62/" title="类加载机制（2）类加载器源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">类加载机制（2）类加载器源码解析</div></div><div class="info-2"><div class="info-item-1">目录 一、类加载器 1、BootstrapClassLoader 启动类加载器 2、ExtensionClassLoader 扩展类加载器 3、ApplicationClassLoader 应用类加载器 4、CustomClassLoader 自定义类加载器 5、线程上下文类加载器   二、java虚拟机入口应用：sun.misc.Launcher 1、sun.misc.Launcher 主入口 2、内部类 ExtClassLoader extends URLClassLoader源码 3、内部类 AppClassLoader  extends URLClassLoader源码 4、真实父类URLClassLoader extends ClassLoader源码   三、双亲委派模型 1、工作流程 2、意义说明   四、ClassLoader源码分析 1、loadClass 实现双亲委派逻辑 2、findClass 通过path找到.class加载进byte[]二进制数组 3、defineClass(byte[] b)...</div></div></div></a><a class="pagination-related" href="/2024/12/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%883%EF%BC%89DexClassLoader%E5%BA%94%E7%94%A8%E7%AF%87/" title="类加载机制（3）DexClassLoader应用篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">类加载机制（3）DexClassLoader应用篇</div></div><div class="info-2"><div class="info-item-1">目录 一、Android中ClassLoader的说明 二、DexClassLoader使用 三、类加载机制的缓存 四、如何避过缓存 五、class二进制文件加载进内存哪个jvm分区？   一、Android中ClassLoader的说明   类加载器 说明    DexClassLoader 可以加载jar&#x2F;apk&#x2F;dex，可以从SD卡中加载未安装的apk；   PathClassLoader 只能加载系统中已经安装过的apk；   二、DexClassLoader使用参数说明    入参 说明    dexPath 表示dex文件的路径，这个路径可以是apk、jar、zip等文件的路径如果是多个文件的路径，可以通过File.pathSeparator来进行分割（在 Windows 上，此字段为 “;”，在 UNIX 上，此字段为 “:”）   optimizedDirectory 用于存储优化后的dex文件，这个目录不能是外部存储，因为Android系统不允许外部存储上的应用进行DEX优化。   librarySearchPath 用于查找...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-1-%E5%9F%BA%E7%A1%80-TODO/" title="线程-1-基础-TODO"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">线程-1-基础-TODO</div></div><div class="info-2"><div class="info-item-1">todo-list:1、阿里三问https://www.jianshu.com/p/fa9a92f517db 目录 一、线程 1、创建线程的方式：理论上只有两种 2、线程状态简版：新建、就绪、阻塞、结束 3、线程状态完整：1、NEW（初始）；2、RUNNING（运行中）&#x2F;READY（就绪）；3、WAITING（等待）；4、TIMED_WAITING(等待超时)；5、BLOCKED（阻塞）；6、TERMINATED（终止）   二、线程的API 1、静态方法 1.1、Thread.yield() 1.2、Thread.sleep()  &lt;1&gt; 抛出InterruptedException时机 &lt;2&gt; interrupted标志清除时机 &lt;3&gt; 和wait()的区别   1.3、Thread.interrupted()   2、普通方法 2.1、new Thread().start() 2.2、new Thread().run() 2.3、new Thread().join() 2.4、new...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-%E7%BA%BF%E7%A8%8B%E9%94%81%E5%88%86%E7%B1%BB/" title="线程-2-线程锁分类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">线程-2-线程锁分类</div></div><div class="info-2"><div class="info-item-1">一、按照其性质分类公平锁&#x2F;非公平锁 公平锁是指多个线程按照申请锁的顺序来获取锁。 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。  对于Java...</div></div></div></a><a class="pagination-related" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-AQS-ReentranLock%E7%BA%BF%E7%A8%8B%E9%94%81/" title="线程-2-AQS-ReentranLock线程锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">线程-2-AQS-ReentranLock线程锁</div></div><div class="info-2"><div class="info-item-1">目录 一、ReentrantLock 组成部分 Sync extends AbstractQueuedSynchronizer NonfairSync extends Sync  FairSync extends Sync   二、ReentrantLock 性质 1、独占锁 2、可重入锁&#x2F;不可重入锁 3、公平锁&#x2F;不公平锁   三、ReentrantLock Api说明 1、lock() 2、lockInterruptibly() 3、tryLock() 4、tryLock(long,TimeUnit) 5、unLock() 6、newCondition()   四、Condition实现通知机制 五、与Synchronized关键字对比  一、ReentrantLock组成部分 Sync extends AbstractQueuedSynchronizer NonfairSync extends SyncFairSync extends Sync二、ReentrantLock 性质1、独占锁 &#x2F;...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">王征</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IRVING18"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:ivring18@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><span>一个通人性的博主，码字不易，用爱发电。希望大家多多支持。</span><img width="250px" src="/img/wechat_pay.png"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">线程池ThreadPoolExecutor源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">所需知识点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90execute-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">源码分析execute()执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81ThreadPoolExecutor-execute-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">一、ThreadPoolExecutor.execute()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ThreadPoolExecutor-addWorker-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">二、ThreadPoolExecutor.addWorker()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Worker%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">三、Worker内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9A"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">Worker存在的意义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9Astate-1-0-1"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">Worker如何实现不可重入锁：state (-1,0,1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">Worker如何控制中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ThreadPoolExecutor-runWorker"><span class="toc-number">2.4.</span> <span class="toc-text">四、ThreadPoolExecutor.runWorker()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ThreadPoolExecutor-getTask-%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">五、ThreadPoolExecutor.getTask()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ThreadPoolExecutor-processWorkerExit-%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">六、ThreadPoolExecutor.processWorkerExit()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81ThreadPoolExecutor-tryTerminate-%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">七、ThreadPoolExecutor.tryTerminate()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81ThreadPoolExecutor-interruptIdleWorkers-%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.</span> <span class="toc-text">八、ThreadPoolExecutor.interruptIdleWorkers()方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-2-%E7%BA%BF%E7%A8%8B%E9%94%81%E5%88%86%E7%B1%BB/" title="线程-2-线程锁分类">线程-2-线程锁分类</a><time datetime="2024-12-27T03:52:19.000Z" title="发表于 2024-12-27 11:52:19">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%883%EF%BC%89%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/" title="线程池（3）终止线程池原理">线程池（3）终止线程池原理</a><time datetime="2024-12-27T03:52:19.000Z" title="发表于 2024-12-27 11:52:19">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%882%EF%BC%89execute()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="线程池（2）execute()执行过程源码分析">线程池（2）execute()执行过程源码分析</a><time datetime="2024-12-27T03:45:07.000Z" title="发表于 2024-12-27 11:45:07">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8(safe)%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" title="线程-3-线程安全(safe)使用总结">线程-3-线程安全(safe)使用总结</a><time datetime="2024-12-27T03:45:00.000Z" title="发表于 2024-12-27 11:45:00">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E7%BA%BF%E7%A8%8B-4-ThreadLocal/" title="线程-4-ThreadLocal">线程-4-ThreadLocal</a><time datetime="2024-12-27T03:44:58.000Z" title="发表于 2024-12-27 11:44:58">2024-12-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bg.png);"><div id="footer-wrap"><div class="copyright">&copy;2024 By 王征</div><div class="footer_custom_text"><a href=""><img class="icp-icon" src="/img/avatar.jpg"><span>一个通人性的博主</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>